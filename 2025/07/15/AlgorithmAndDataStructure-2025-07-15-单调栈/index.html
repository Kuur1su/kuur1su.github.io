<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>单调栈 | Steins;Gate</title><meta name="author" content="Kurisu"><meta name="copyright" content="Kurisu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="单调栈的思路  入栈元素要求严格大压小或者小压大，具体情况取决于处理问题的情况 如果要求弹出元素，立即结算弹出元素的信息和所求信息 如果全部遍历结束，清算栈内剩余元素   单调栈处理的情况一般属于找到某一个值左边第一个小（大）于，和右边第一个小（大）于的值。由于单调栈的数据结构特征可以很轻松的得出压在弹出元素下方的是左边小（大）于的值，使元素弹出的值是右边小（大）于的值。  一些例题 NK-单调栈">
<meta property="og:type" content="article">
<meta property="og:title" content="单调栈">
<meta property="og:url" content="https://kuur1su.github.io/2025/07/15/AlgorithmAndDataStructure-2025-07-15-%E5%8D%95%E8%B0%83%E6%A0%88/index.html">
<meta property="og:site_name" content="Steins;Gate">
<meta property="og:description" content="单调栈的思路  入栈元素要求严格大压小或者小压大，具体情况取决于处理问题的情况 如果要求弹出元素，立即结算弹出元素的信息和所求信息 如果全部遍历结束，清算栈内剩余元素   单调栈处理的情况一般属于找到某一个值左边第一个小（大）于，和右边第一个小（大）于的值。由于单调栈的数据结构特征可以很轻松的得出压在弹出元素下方的是左边小（大）于的值，使元素弹出的值是右边小（大）于的值。  一些例题 NK-单调栈">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kuur1su.github.io/image/photo02.jpg">
<meta property="article:published_time" content="2025-07-15T05:15:16.000Z">
<meta property="article:modified_time" content="2025-07-16T06:33:08.366Z">
<meta property="article:author" content="Kurisu">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="单调栈">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kuur1su.github.io/image/photo02.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "单调栈",
  "url": "https://kuur1su.github.io/2025/07/15/AlgorithmAndDataStructure-2025-07-15-%E5%8D%95%E8%B0%83%E6%A0%88/",
  "image": "https://kuur1su.github.io/image/photo02.jpg",
  "datePublished": "2025-07-15T05:15:16.000Z",
  "dateModified": "2025-07-16T06:33:08.366Z",
  "author": [
    {
      "@type": "Person",
      "name": "Kurisu",
      "url": "https://kuur1su.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/image/Steins.ico"><link rel="canonical" href="https://kuur1su.github.io/2025/07/15/AlgorithmAndDataStructure-2025-07-15-%E5%8D%95%E8%B0%83%E6%A0%88/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '单调栈',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background:url(https://Kuur1su.github.io/image/school_theme.jpg)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/kurisu3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/photo02.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Steins;Gate</span></a><a class="nav-page-title" href="/"><span class="site-name">单调栈</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">单调栈</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-15T05:15:16.000Z" title="发表于 2025-07-15 13:15:16">2025-07-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-16T06:33:08.366Z" title="更新于 2025-07-16 14:33:08">2025-07-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-07-16 14:33:08&quot;}" hidden></div><h2 id="单调栈的思路">单调栈的思路</h2>
<ol>
<li>入栈元素要求严格大压小或者小压大，具体情况取决于处理问题的情况</li>
<li>如果要求弹出元素，立即结算弹出元素的信息和所求信息</li>
<li>如果全部遍历结束，清算栈内剩余元素</li>
</ol>
<blockquote>
<p>单调栈处理的情况一般属于找到某一个值左边第一个小（大）于，和右边第一个小（大）于的值。由于单调栈的数据结构特征可以很轻松的得出压在弹出元素下方的是左边小（大）于的值，使元素弹出的值是右边小（大）于的值。</p>
</blockquote>
<h2 id="一些例题">一些例题</h2>
<h3 id="NK-单调栈进阶">NK-单调栈进阶</h3>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/2a2c00e7a88a498693568cef63a4b7bb">NK-单调栈进阶</a></p>
<h4 id="思路：">思路：</h4>
<p>因为有可能存在重复值，我们需要在结算过后检查每个答案是否正确，如果出现等于的请款依旧结算答案，但是暂定，最后统一修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : a) cin &gt;&gt; i;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 1. 首先入栈</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果栈空或者栈顶元素小于即将到的数，就弹出，否则压入</span></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; a[i] &lt;= a[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">            <span class="comment">// 弹出的情况：</span></span><br><span class="line">            <span class="type">int</span> idx = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            left[idx] = (!st.<span class="built_in">empty</span>()) ? st.<span class="built_in">top</span>() : <span class="number">-1</span>;</span><br><span class="line">            right[idx] = i;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 压入</span></span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 结算阶段：</span></span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> idx = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        left[idx] = (!st.<span class="built_in">empty</span>()) ? st.<span class="built_in">top</span>() : <span class="number">-1</span>;</span><br><span class="line">        right[idx] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 纠错阶段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 因为相同的值也会弹出，所以左侧的答案一定是正确的，只需要修改右边的答案即可</span></span><br><span class="line">        <span class="keyword">while</span> (right[i] != <span class="number">-1</span> &amp;&amp; a[i] == a[right[i]]) &#123;</span><br><span class="line">            <span class="comment">// 右边的答案就是相等的元素右边的答案，因为两个值相等所以答案也是相同的</span></span><br><span class="line">            right[i] = right[right[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; left[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; right[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-739-每日温度">LeetCode-739.每日温度</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/description/">LeetCode-739.每日温度</a></p>
<h4 id="思路：-2">思路：</h4>
<p>保留单调栈的思路，相当于找<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>下标右侧第一个大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">temperature[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal">re</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 由于不用管左侧的情况，所以相等的值也可以直接压入不用弹出结算。</span></span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> idx = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                right[idx] = i - idx;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> idx = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            right[idx] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-907-子数组的最小值之和">LeetCode-907.子数组的最小值之和</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-subarray-minimums/">LeetCode-907.子数组的最小值之和</a></p>
<h4 id="思路：-3">思路：</h4>
<p>我们可以用单调栈收集每个位置元素的比它小的左右最近的值，然后再左右区间之内的，包括该元素的子数组一定都是满足条件的，通过这个方法可以以非常小的时间复杂度完成这道题目。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 一个小细节：</span></span><br><span class="line">            <span class="comment">// 这里如果值相等也可以直接弹出元素结算，因为元素相等的话前面元素没有计算到的部分</span></span><br><span class="line">            <span class="comment">// 后面的元素会帮忙补上，可以不用在乎相同元素的冲突问题</span></span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; arr[i] &lt;= arr[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> idx = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left = st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st.<span class="built_in">top</span>();</span><br><span class="line">                ans = (ans + (<span class="type">long</span> <span class="type">long</span>) (idx - left) * (i - idx) * arr[idx]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> idx = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> left = st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st.<span class="built_in">top</span>();</span><br><span class="line">            ans = (ans + (<span class="type">long</span> <span class="type">long</span>) (idx - left) * (n - idx) * arr[idx]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-84-柱状图中最大的矩形">LeetCode-84.柱状图中最大的矩形</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">LeetCode-84.柱状图中最大的矩形</a></p>
<h4 id="思路：-4">思路：</h4>
<p>与上一题类似，用单调栈找出以某一个高度为矩形高的左右两边的最近小的值，看看能不能把这个高度往两侧扩展，然后不停的收集答案的最大值即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 同样不需要考虑相等值得情况，因为后面会重新算回来的。</span></span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; heights[i] &lt;= heights[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> idx = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left = st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="comment">// 直接把heights[idx]得高度当成矩形得高往两侧扩展，(i - left - 1)就是长</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (i - left - <span class="number">1</span>) * heights[idx]);</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> idx = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> left = st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st.<span class="built_in">top</span>();</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (n - left - <span class="number">1</span>) * heights[idx]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-85-最大矩形">LeetCode-85.最大矩形</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-rectangle/description/">LeetCode-85.最大矩形</a></p>
<h4 id="思路：-5">思路：</h4>
<p>不难发现，这题与上题类似，但是区别在于每一次处理一行的时候都要更新一下这一行的数据，变成与上题类似的情况，再计算当前行的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">height</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 封装一下上一题得过程，用来处理每一次的答案</span></span><br><span class="line">        <span class="keyword">auto</span> work = [&amp;]() -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &lt;= height[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    <span class="type">int</span> idx = st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> left = st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st.<span class="built_in">top</span>();</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, (i - left - <span class="number">1</span>) * height[idx]);</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> idx = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left = st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st.<span class="built_in">top</span>();</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (m - left - <span class="number">1</span>) * height[idx]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 主过程</span></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 每一行计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="comment">// 把每一行的高度进行更新</span></span><br><span class="line">                <span class="comment">// 如果是0说明连续的1折断</span></span><br><span class="line">                <span class="comment">// 如果是1就把先前的结果累加1当成新的高度</span></span><br><span class="line">                height[j] = matrix[i][j] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : ++height[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理完一行的结果后开始结算答案并更新</span></span><br><span class="line">            cur = <span class="built_in">work</span>();</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈的进阶用法">单调栈的进阶用法</h2>
<p>单调栈是维持求解答案的可能性</p>
<ol>
<li>单调栈里的所有对象按照 <strong>规定好的单调性来组织</strong></li>
<li>当某个对象进入单调栈时，从栈顶开始依次淘汰单调栈里 <strong>对后续求解答案没有帮助</strong>的对象</li>
<li>每个对象从栈顶弹出时，<strong>结算当前对象参与的答案</strong>，随后这个对象<strong>不再参与后续求解答案的过程</strong></li>
<li>发现单调性！用单调栈的特征去实现</li>
</ol>
<h2 id="进阶题目">进阶题目</h2>
<h3 id="LeetCode-962-最大宽度坡">LeetCode-962.最大宽度坡</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-width-ramp/">LeetCode-962.最大宽度坡</a></p>
<h4 id="思路：-6">思路：</h4>
<p>我们用数组的方式来维护栈，这样操作通常比栈更好使。我们定义栈中的元素是可能出现在坡的元组左侧的元素，所以单调性是小压大。第一个元素必须入栈，栈收集完毕后从后往前遍历数组，找到对应的元组和距离。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxWidthRamp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 首先填充栈空间，用递减的方式填充栈（用到一点贪心的思想）</span></span><br><span class="line">        <span class="comment">// 这样可以避免掉一些无意义的讨论</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        stk.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[stk.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 收集答案阶段：</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; !stk.<span class="built_in">empty</span>(); i--) &#123;</span><br><span class="line">            <span class="comment">// 从后往前遍历，如果nums[i]比栈中最后的元素大就弹出，收集答案</span></span><br><span class="line">            <span class="comment">// 查看接下来的栈内是否存在nums[i] &gt; nums[stk.back()]</span></span><br><span class="line">            <span class="comment">// 直到找到最大的ans</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[stk.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> idx = stk.<span class="built_in">back</span>();</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i - idx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-316-去除重复字母">LeetCode-316.去除重复字母</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicate-letters/">LeetCode-316.去除重复字母</a></p>
<h4 id="思路：-7">思路：</h4>
<p>由字典序最小可以和单调栈联想起来，我们的思路是统计字母的词频，然后按照大压小的方式入栈。</p>
<p>那么出栈的机制就是如果这个字母在外面还有+栈非空+入栈元素要大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>k</mi><mi mathvariant="normal">.</mi><mi>t</mi><mi>o</mi><mi>p</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">stk.top()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">.</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>的元素就讲栈顶元素踢出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicateLetters</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 用数组来表示栈结构</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; cnt;   <span class="comment">// 统计词频    </span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">exist</span><span class="params">(<span class="number">26</span>)</span></span>;         <span class="comment">// 判断栈内是否存在相同元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 单调栈主过程：</span></span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历到哪个字母，字母的频率就-1</span></span><br><span class="line">            cnt[s[i]]--;</span><br><span class="line">            <span class="keyword">if</span> (!exist[s[i] - <span class="string">&#x27;a&#x27;</span>]) &#123; <span class="comment">// 如果字母是不在栈中的，入栈</span></span><br><span class="line">                <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; </span><br><span class="line">                       s[i] &lt; s[stk.<span class="built_in">back</span>()] &amp;&amp; cnt[s[stk.<span class="built_in">back</span>()]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    exist[s[stk.<span class="built_in">back</span>()] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">                    stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                exist[s[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : stk) &#123;</span><br><span class="line">            ans += s[ch];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-2289-使数组按非递减顺序排列">LeetCode-2289.使数组按非递减顺序排列</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/steps-to-make-array-non-decreasing/">LeetCode-2289.使数组按非递减顺序排列</a></p>
<h4 id="思路1：">思路1：</h4>
<p>我们用纯粹的单调栈来完成，往栈内存的元素是一个对&lt;下标， 处理完后续步骤需要的轮数&gt;</p>
<p>有大的数进来了就要花1轮的时间处理后续的内容，后续的内容需要花多少轮已经在栈顶元素的对中表明了只需要比较谁更大然后继承后续的轮数即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalSteps</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; stk;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> times = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[stk.<span class="built_in">back</span>().first]) &#123;</span><br><span class="line">                times = <span class="built_in">max</span>(++times, stk.<span class="built_in">back</span>().second);</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">emplace_back</span>(i, times);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, times);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路2：">思路2：</h4>
<p>单调栈+dp，和第一种思路大同小异</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalSteps</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stk, dp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; nums[stk.<span class="built_in">back</span>()] &lt; nums[i]) &#123;</span><br><span class="line">				cnt = <span class="built_in">max</span>(cnt + <span class="number">1</span>, dp.<span class="built_in">back</span>());</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                dp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            stk.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            dp.<span class="built_in">emplace_back</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-1504-统计全1子矩形的个数">LeetCode-1504.统计全1子矩形的个数</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-submatrices-with-all-ones/description/">LeetCode-1504.统计全1子矩形的个数</a></p>
<h4 id="思路：-8">思路：</h4>
<p>思路和先前的最大矩形差不多，还是压缩矩形的思路，还是从一维柱状图开始思考，再到二维图</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubmat</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">height</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> work = [&amp;]() -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">			<span class="type">int</span> left, len, bottom, down;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; height[i] &lt;= height[stk.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">                    <span class="type">int</span> cur = stk.<span class="built_in">back</span>();</span><br><span class="line">                    stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                    <span class="comment">// 注意，如果遇到相同的值就直接弹出，但是不结算，用i位置的值来结算</span></span><br><span class="line">                    <span class="comment">// 因为height[cur] == height[i]所以i位置会把cur位置的值也结算在内</span></span><br><span class="line">                    <span class="keyword">if</span> (height[cur] &gt; height[i]) &#123;</span><br><span class="line">                        left = stk.<span class="built_in">empty</span>() ? <span class="number">-1</span> : stk.<span class="built_in">back</span>();</span><br><span class="line">                        len = i - left - <span class="number">1</span>;</span><br><span class="line">                        bottom = <span class="built_in">max</span>((left == <span class="number">-1</span> ? <span class="number">0</span> : height[left]), height[i]);</span><br><span class="line">                        ans += len * (height[cur] - bottom) * (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> cur = stk.<span class="built_in">back</span>();</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                left = stk.<span class="built_in">empty</span>() ? <span class="number">-1</span> : stk.<span class="built_in">back</span>();</span><br><span class="line">                len = n - left - <span class="number">1</span>;</span><br><span class="line">                down = (left == <span class="number">-1</span> ? <span class="number">0</span> : height[left]);</span><br><span class="line">                ans += (height[cur] - down) * len * (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 压缩数组，结算每一行的答案</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                height[j] = (mat[i][j] == <span class="number">0</span>) ? <span class="number">0</span> : ++height[j];</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="built_in">work</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://kuur1su.github.io">Kurisu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kuur1su.github.io/2025/07/15/AlgorithmAndDataStructure-2025-07-15-%E5%8D%95%E8%B0%83%E6%A0%88/">https://kuur1su.github.io/2025/07/15/AlgorithmAndDataStructure-2025-07-15-%E5%8D%95%E8%B0%83%E6%A0%88/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://kuur1su.github.io" target="_blank">Steins;Gate</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a></div><div class="post-share"><div class="social-share" data-image="/image/photo02.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/image/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/image/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/15/AlgorithmAndDataStructure-2025-07-15-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E6%B3%95/" title="二分答案法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">二分答案法</div></div><div class="info-2"><div class="info-item-1">二分答案法的套路流程  估计答案最终范围是什么 分析 问题的答案 和 给定条件 之间的 单调性, 大部分时候只需用到自然智慧 建立一个work函数， 判断答案固定的情况下给定的条件是否达标 在 最终答案的可能上不断二分搜索，直到找到最后答案  一些例题 LeetCode-875.爱吃香蕉的珂珂 LeetCode-875.爱吃香蕉的珂珂 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public:    int minEatingSpeed(vector&lt;int&gt;&amp; piles, int h) &#123;        int n = piles.size();        int r = 0, l = 1;        // 我们可以先找到答案可能的范围，速度就在[0, maxpiles]之间        for (auto const &amp;i : piles) &#123;            r = max(r, i); ...</div></div></div></a><a class="pagination-related" href="/2025/07/16/AlgorithmAndDataStructure-2025-07-16-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" title="单调队列"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/train.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">单调队列</div></div><div class="info-2"><div class="info-item-1">单调队列的基本用法  滑动窗口时，用双端队列维护一个区间的最小（大）值   与单调栈的不同点在于，单调队列可以从两侧进出，单调栈只能从一个口进出  一些例题 LeetCode-239.滑动窗口最大值 LeetCode-239.滑动窗口最大值 思路： 我们可以用一个单调队列来时时更新滑动窗口区间的最大值，非常经典的例题，单调队列的最基本用法 123456789101112131415161718192021222324252627282930313233class Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        int n = nums.size();        deque&lt;int&gt; dq;        vector&lt;int&gt; ans;		        // 初始化最开始的窗口，定位k - 1大小        for (int i = 0; i &lt; k - 1;...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/11/AlgorithmContest-2025-08-11-ABC418/" title="ABC418"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/screenshot03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-11</div><div class="info-item-2">ABC418</div></div><div class="info-2"><div class="info-item-1">ABC418  AC 4/7  C - Flush On the poker table, there are tea bags of NNN different flavors. The flavors are numbered from 111 through NNN, and there are AiA_iAi​ tea bags of flavor iii (1≤i≤N1 \leq i \leq N1≤i≤N). You will play a game using these tea bags. The game has a parameter called difficulty between 111 and A1+⋯+ANA_1 + \dots + A_NA1​+⋯+AN​, inclusive. A game of difficulty bbb proceeds as follows:  You declare an integer xxx. Here, it must satisfy b≤x≤A1+⋯+ANb \leq x \leq A_1 + \dots +...</div></div></div></a><a class="pagination-related" href="/2025/08/18/AlgorithmContest-2025-08-18-NKRound105/" title="NKRound105"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/Roxy1.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-18</div><div class="info-item-2">NKRound105</div></div><div class="info-2"><div class="info-item-1">NK Round 105  AC 5/6  C.小苯的01矩阵构造 思路： 观察容易发现，只可能kkk是偶数，奇数不可能出现 123456789101112131415161718192021222324int main() &#123;    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    if (k % 2 == 1) &#123;        std::cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;    &#125; else &#123;        for (int i = 0; i &lt; n; i++) &#123;            for (int j = 0; j &lt; n; j++) &#123;                if (i == j &amp;&amp; i &lt; k / 2) &#123;            ...</div></div></div></a><a class="pagination-related" href="/2025/08/11/AlgorithmContest-2025-08-11-CF1042/" title="CF1042"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-11</div><div class="info-item-2">CF1042</div></div><div class="info-2"><div class="info-item-1">CF1042 (Div.3)  AC 5 / 8  C. Make it Equal Given two multisets SSS and TTT of size nnn and a positive integer kkk, you may perform the following operations any number (including zero) of times on SSS:  Select an element xxx in SSS, and remove one occurrence of xxx in SSS. Then, either insert x+kx+kx+k into SSS, or insert ∣x−k∣|x-k|∣x−k∣ into SSS.  Determine if it is possible to make SSS equal to TTT. Two multisets SSS and TTT are equal if every element appears the same number of times in SSS...</div></div></div></a><a class="pagination-related" href="/2025/08/11/AlgorithmContest-2025-08-11-NKRound104/" title="NKRound104"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/Roxy1.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-11</div><div class="info-item-2">NKRound104</div></div><div class="info-2"><div class="info-item-1">NK Round 104  AC 5/6  C.小红的不动点分配 \hspace{15pt}小红拿到了 2×n2\times n2×n 个元素，现在她想将这些元素划分为两组（每组恰好 nnn 个元素），且两组内部的顺序均可任意重排。 \hspace{15pt}她想知道，这两个数组的不动点数量之和最多是多少，请你帮帮她。 【名词解释】 \hspace{15pt}不动点：定义整数 i(1≦i≦m)i\left(1\leqq i \leqq m \right)i(1≦i≦m) 是长度为 mmm 的数组 {a1,a2,…,am}\{a_1,a_2,\dots,a_m\}{a1​,a2​,…,am​} 的一个不动点，当且仅当满足 ai=ia_i = iai​=i。 12345678910111213141516171819202122232425262728constexpr int M = 2e5; int main() &#123;    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);         int...</div></div></div></a><a class="pagination-related" href="/2025/04/10/AlgorithmAndDataStructure-2025-04-10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/screenshot05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-10</div><div class="info-item-2">动态规划</div></div><div class="info-2"><div class="info-item-1"> 动态规划   动态规划是一个很大的板块，分为很多的方面给，这篇文章只是给出一个最基本的概念，后续动态规划的各种类型会逐渐更新。  一、介绍 动态规划其实就是一种把大问题分解成小的并且有关联的子问题，子问题之间有重叠的部分，可以通过子问题的答案推断出后续问题的答案。 动态规划还可以是当成一种缓存表，把递归调用得到的结果用一张dpdpdp表存起来，以后遇到相似的情况直接从缓存中找答案，用空间换时间。 然后是严格位置依赖的动态规划，这种方式需要找到状态定义和状态转移方程，而往往找出最优的状态定义和转移方程是困难的，需要花大量的时间积累经验以及依赖一点灵感。 二、分类 动态规划可以分为一维动态规划，二维动态规划，01背包，完全背包，分组背包，多重背包和混合背包，区间dp，状压dp等等 </div></div></div></a><a class="pagination-related" href="/2025/04/15/AlgorithmAndDataStructure-2025-04-15-%E5%9B%BE/" title="图"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/train.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">图</div></div><div class="info-2"><div class="info-item-1"> 图  一、介绍  图的组成和分类 图的形式可以说是非常直观，由顶点和边构成，图分为无向图(Undirected Graph)，有向图(Directed Graph)，加权图(Weighted Graph)。 图的关键术语  度 : 一个顶点连接的边数（无向图中）。 入度/出度 : 有向图中指向某顶点的边数（入度）或从该顶点出发的边数（出度）。 路径 : 从一个顶点到另一个顶点的边序列。 环 : 起点和终点相同的路径。 连通图 : 任意两个顶点间都存在路径（无向图）。 强连通图 : 有向图中任意两顶点间存在双向路径。   图的表示方法   邻接矩阵（Adjacency Matrix） 用二维数组存储顶点间的连接关系。矩阵元素 matrix[i][j] 表示顶点 i 到 j 是否存在边（或边的权重）。 优点：快速判断两顶点是否相连；缺点：空间复杂度高（O(V²)），适合稠密图。   邻接表（Adjacency...</div></div></div></a><a class="pagination-related" href="/2025/04/15/AlgorithmAndDataStructure-2025-04-15-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E5%88%86%E6%B2%BB/" title="归并排序和归并分治"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">归并排序和归并分治</div></div><div class="info-2"><div class="info-item-1">  归并排序和归并分治  一、归并排序  介绍 不得不说，归并排序是一种非常稳定的排序方式，时间复杂度可以达到O(nlogn)O(nlogn)O(nlogn)级别，同样也是最坏情况下的最好的排序方式，主要思想就是把一个大问题分成两个子问题，把子问题搞定后再来合并 代码实现123456789101112131415161718192021222324252627282930313233vector&lt;int&gt; temp;void mergeSort(vector&lt;int&gt;&amp; a, int l, int r) &#123;    if (l &gt;= r) return;    int m = (l + r) / 2;    mergeSort(a, l, m);    mergeSort(a, m + 1, r);    int i = l, j = m + 1, k = l;    while (i &lt;= m &amp;&amp; j &lt;= r) &#123;        temp[k++] = (a[i] &lt;= a[j])...</div></div></div></a><a class="pagination-related" href="/2025/04/25/AlgorithmAndDataStructure-2025-04-25-%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-25</div><div class="info-item-2">并查集</div></div><div class="info-2"><div class="info-item-1"> 并查集  一、介绍 并查集是一种很优雅的技巧，能够让时间复杂度维持在常数级别，大概是O(α(n))O(α(n))O(α(n))(ααα 是反阿克曼函数) 把有相同性质的元素合并在一个元素中。 二、代码实现 1234567891011121314151617181920212223242526272829class DSU &#123;private:    vector&lt;int&gt; parent;public:    //初始化    DSU(int n) : parent(n + 1) &#123;        for (int i = 0; i &lt;= n; i++) &#123;            parent[i] = i;        &#125;    &#125;    //带路径查找并压缩    int find(int x) &#123;        if (parent[x] != x) &#123;            parent[x] = find(parent[x]);        &#125;       ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/kurisu3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Kurisu</div><div class="author-info-description">学而不思则罔，思而不学则殆</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Kuur1su"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Kuur1su" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3325771476@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎参观！会随缘更新自己的学习生活quq。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">1.</span> <span class="toc-text">单调栈的思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E4%BE%8B%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">一些例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NK-%E5%8D%95%E8%B0%83%E6%A0%88%E8%BF%9B%E9%98%B6"><span class="toc-number">2.1.</span> <span class="toc-text">NK-单调栈进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">2.1.1.</span> <span class="toc-text">思路：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-number">2.2.</span> <span class="toc-text">LeetCode-739.每日温度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-2"><span class="toc-number">2.2.1.</span> <span class="toc-text">思路：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-907-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C"><span class="toc-number">2.3.</span> <span class="toc-text">LeetCode-907.子数组的最小值之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-3"><span class="toc-number">2.3.1.</span> <span class="toc-text">思路：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="toc-number">2.4.</span> <span class="toc-text">LeetCode-84.柱状图中最大的矩形</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-4"><span class="toc-number">2.4.1.</span> <span class="toc-text">思路：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2"><span class="toc-number">2.5.</span> <span class="toc-text">LeetCode-85.最大矩形</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-5"><span class="toc-number">2.5.1.</span> <span class="toc-text">思路：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">单调栈的进阶用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E9%A2%98%E7%9B%AE"><span class="toc-number">4.</span> <span class="toc-text">进阶题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-962-%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6%E5%9D%A1"><span class="toc-number">4.1.</span> <span class="toc-text">LeetCode-962.最大宽度坡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-6"><span class="toc-number">4.1.1.</span> <span class="toc-text">思路：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D"><span class="toc-number">4.2.</span> <span class="toc-text">LeetCode-316.去除重复字母</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-7"><span class="toc-number">4.2.1.</span> <span class="toc-text">思路：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-2289-%E4%BD%BF%E6%95%B0%E7%BB%84%E6%8C%89%E9%9D%9E%E9%80%92%E5%87%8F%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97"><span class="toc-number">4.3.</span> <span class="toc-text">LeetCode-2289.使数组按非递减顺序排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1%EF%BC%9A"><span class="toc-number">4.3.1.</span> <span class="toc-text">思路1：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2%EF%BC%9A"><span class="toc-number">4.3.2.</span> <span class="toc-text">思路2：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-1504-%E7%BB%9F%E8%AE%A1%E5%85%A81%E5%AD%90%E7%9F%A9%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">LeetCode-1504.统计全1子矩形的个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-8"><span class="toc-number">4.4.1.</span> <span class="toc-text">思路：</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/22/AlgorithmAndDataStructure-2025-08-22-%E5%B8%B8%E8%A7%81%E6%A8%A1%E6%9D%BF/" title="常见模板"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见模板"/></a><div class="content"><a class="title" href="/2025/08/22/AlgorithmAndDataStructure-2025-08-22-%E5%B8%B8%E8%A7%81%E6%A8%A1%E6%9D%BF/" title="常见模板">常见模板</a><time datetime="2025-08-22T14:40:00.000Z" title="发表于 2025-08-22 22:40:00">2025-08-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/18/AlgorithmContest-2025-08-18-NKRound105/" title="NKRound105"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/Roxy1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NKRound105"/></a><div class="content"><a class="title" href="/2025/08/18/AlgorithmContest-2025-08-18-NKRound105/" title="NKRound105">NKRound105</a><time datetime="2025-08-18T00:21:14.000Z" title="发表于 2025-08-18 08:21:14">2025-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/17/AlgorithmAndDataStructure-2025-08-17-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" title="容斥原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="容斥原理"/></a><div class="content"><a class="title" href="/2025/08/17/AlgorithmAndDataStructure-2025-08-17-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" title="容斥原理">容斥原理</a><time datetime="2025-08-17T01:16:38.000Z" title="发表于 2025-08-17 09:16:38">2025-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/17/AlgorithmAndDataStructure-2025-08-17-%E5%BF%AB%E9%80%9F%E5%B9%82/" title="快速幂"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/screenshot08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="快速幂"/></a><div class="content"><a class="title" href="/2025/08/17/AlgorithmAndDataStructure-2025-08-17-%E5%BF%AB%E9%80%9F%E5%B9%82/" title="快速幂">快速幂</a><time datetime="2025-08-17T01:16:22.000Z" title="发表于 2025-08-17 09:16:22">2025-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/17/AlgorithmAndDataStructure-2025-08-17-%E8%B4%A8%E6%95%B0%E7%AD%9B/" title="质数筛"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/screenshot06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="质数筛"/></a><div class="content"><a class="title" href="/2025/08/17/AlgorithmAndDataStructure-2025-08-17-%E8%B4%A8%E6%95%B0%E7%AD%9B/" title="质数筛">质数筛</a><time datetime="2025-08-17T01:16:01.000Z" title="发表于 2025-08-17 09:16:01">2025-08-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By Kurisu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  });
</script>
<canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/light.js"></script><script defer src="/js/runtimes.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><!-- hexo injector body_end end --></body></html>