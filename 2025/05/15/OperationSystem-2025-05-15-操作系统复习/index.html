<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统复习 | Steins;Gate</title><meta name="author" content="Kurisu"><meta name="copyright" content="Kurisu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="操作系统OS  一、绪论  操作系统在计算机系统中的地位  存储程序式计算机的结构和特点   CPU 一种能够解释指令、执行指令并控制操作顺序的硬设备，它由算数逻辑单元(ALU)和控制单元构成。  ALU 包含一个能完成算术逻辑操作的功能单元以及一组通用寄存器和状态寄存器。通用寄存器为功能单元提供操作数，并接受保存操作结果。状态寄存器保存着处理机运行过程中的当前状态。 控制单元 包含一个程序计数">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统复习">
<meta property="og:url" content="https://kuur1su.github.io/2025/05/15/OperationSystem-2025-05-15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Steins;Gate">
<meta property="og:description" content="操作系统OS  一、绪论  操作系统在计算机系统中的地位  存储程序式计算机的结构和特点   CPU 一种能够解释指令、执行指令并控制操作顺序的硬设备，它由算数逻辑单元(ALU)和控制单元构成。  ALU 包含一个能完成算术逻辑操作的功能单元以及一组通用寄存器和状态寄存器。通用寄存器为功能单元提供操作数，并接受保存操作结果。状态寄存器保存着处理机运行过程中的当前状态。 控制单元 包含一个程序计数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kuur1su.github.io/image/theme01.jpg">
<meta property="article:published_time" content="2025-05-15T06:11:24.000Z">
<meta property="article:modified_time" content="2025-07-16T06:33:08.362Z">
<meta property="article:author" content="Kurisu">
<meta property="article:tag" content="计算机">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kuur1su.github.io/image/theme01.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "操作系统复习",
  "url": "https://kuur1su.github.io/2025/05/15/OperationSystem-2025-05-15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/",
  "image": "https://kuur1su.github.io/image/theme01.jpg",
  "datePublished": "2025-05-15T06:11:24.000Z",
  "dateModified": "2025-07-16T06:33:08.362Z",
  "author": [
    {
      "@type": "Person",
      "name": "Kurisu",
      "url": "https://kuur1su.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/image/Steins.ico"><link rel="canonical" href="https://kuur1su.github.io/2025/05/15/OperationSystem-2025-05-15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统复习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background:url(https://Kuur1su.github.io/image/school_theme.jpg)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/kurisu3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/theme01.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Steins;Gate</span></a><a class="nav-page-title" href="/"><span class="site-name">操作系统复习</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">操作系统复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-15T06:11:24.000Z" title="发表于 2025-05-15 14:11:24">2025-05-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-16T06:33:08.362Z" title="更新于 2025-07-16 14:33:08">2025-07-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">17.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-07-16 14:33:08&quot;}" hidden></div><h1><center> <em><strong>操作系统OS</strong></em> </center></h1>
<h2 id="一、绪论"><strong>一、绪论</strong></h2>
<ol>
<li><strong>操作系统在计算机系统中的地位</strong>
<ol>
<li><strong>存储程序式计算机的结构和特点</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="冯诺伊曼计算机体系结构">
<ul>
<li><strong>CPU</strong><br>
一种能够解释指令、执行指令并控制操作顺序的硬设备，它由<strong>算数逻辑单元(ALU)<strong>和</strong>控制单元</strong>构成。
<ul>
<li><strong>ALU</strong><br>
包含一个能完成算术逻辑操作的功能单元以及一组<strong>通用寄存器</strong>和<strong>状态寄存器</strong>。<strong>通用寄存器</strong>为功能单元提供操作数，并接受保存操作结果。<strong>状态寄存器</strong>保存着处理机运行过程中的当前状态。</li>
<li><strong>控制单元</strong><br>
包含一个<strong>程序计数器(Program Counter, PC)</strong>，一个<strong>指令寄存器(Istruction Register, IR)</strong>。程序计数器指示下一步应该执行的指令，指令寄存器包含当前指令的拷贝。</li>
</ul>
</li>
<li><strong>主存(Main Memory)</strong><br>
组成计算机的重要部件，其作用是存放指令和数据，并能由中央处理器直接随机存取。主存接口由<strong>存储地址寄存器(Memory Address Register, MAR)</strong>、**存储数据寄存器(Memory Data Register, MDR)<strong>以及</strong>命令寄存器(Command Register, CR)**三个寄存器组成。现代计算机为了提高性能，兼顾合理的造价，往往采用多级存储体系。多级存储体系由存储容量小、存取速度高的高速缓冲存储器，存储容量和存取速度适中的主存储器，存储容量大但存取速度慢的辅存储器组成。</li>
<li><strong>输入/输出设备(I/O设备)</strong><br>
负责信息传输，将数据从外部世界传入计算机内，或将主存中的内容传输到计算机的外部设备。</li>
</ul>
</li>
<li><strong>操作系统与计算机各系统层次之间的关系</strong><br>
硬设备组成的机器称为<strong>裸机</strong>，裸机上必须配备<strong>软件</strong>才能满足用户的各种需求。软件由程序、数据和在研制过程中形成的各种文档资料组成，可以分为以下3类：
<ol>
<li>系统软件：操作系统、编译程序、程序设计语言，以及与计算机密切相关的程序</li>
<li>应用软件：各种应用程序，软件包</li>
<li>工具软件：各种诊断程序、检查程序、引导程序<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90.png" alt="计算机系统组成"><br>
软件和硬件有机结合，一起构成了计算机系统。一个重要的系统软件称为操作系统，它管理系统中的各种软、硬件资源，控制用户和应用程序的工作流程，将系统各部件有机地融合成一个整体，使计算机真正的体现了系统的完整性和可利用性。</li>
</ol>
</li>
<li><strong>操作系统与计算机体系结构的关系</strong><br>
早期的计算机上配置的操作系统是单用户操作系统。允许用户独占计算机系统的各种资源。除了CPU和外部设备有可能提供并行操作外，其余活动都是顺序操作。这种顺序计算模型容易实现，但是计算机性能和资源利用率不能充分发挥。<br><br>
人们研究与并行计算模型一致的计算机系统结构，出现了多处理及系统、消息传递型多计算机等具有并行处理能力的计算机系统结构。</li>
</ol>
</li>
<li><strong>操作系统的形成和发展</strong>
<ol>
<li><strong>操作系统发展的初级阶段</strong>
<ol>
<li><strong>早期批处理</strong><br>
每个用户将需要计算机解决的任务组织成一道作业。每个作业包括程序、数据和一个作业说明书。作业说明书提供用户标识、用户程序所需的编译程序、系统资源等信息。详见(P7)。</li>
<li><strong>脱机批处理</strong><br>
脱机批处理系统由主机和卫星机组成，主机负责计算，卫星机负责I/O工作。实现作业的自动过渡。</li>
<li><strong>执行系统</strong><br>
执行系统(也称批处理系统)节省了卫星机，降低了成本，实现了主机和通道、主机和外设并行操作，提高了系统的安全性。批处理系统利用中断和通道技术实现了中央处理机和I/O设备的并行操作。系统负责用户的I/O传输工作，检查用户I/O命令的合法性，避免了由于不合法的I/O命令造成的对系统的威胁。</li>
</ol>
</li>
<li><strong>操作系统的形成</strong>
<ol>
<li><strong>多道程序设计技术</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E5%B7%A5%E4%BD%9C%E7%A4%BA%E4%BE%8B.png" alt="多道程序工作示例"></li>
<li><strong>分时技术</strong><br>
在批处理系统中引入了多道程序设计技术，实现了多道成批处理。人们希望能直接控制程序的运行，这种操作方式称为联机操作方式。<br>
分时技术，就是把处理机时间划分成很短的时间片轮流地分配给各个用户程序使用，如果某个用户程序在分配的时间片用完之前还未完成计算，该程序九暂停执行，等待下一轮继续计算，此时处理机让给另一个用户程序使用。采用分时技术的系统称为分时系统，分时系统的响应时间一般为秒级。</li>
</ol>
</li>
<li><strong>操作系统的基本概念</strong>
<ol>
<li><strong>操作系统的定义</strong><br>
组成计算机系统的软件包括系统软件、应用软件和工具软件。其中，有数据库系统，各种程序设计语言和相应的编译系统，负责维护系统正常工作的查错程序、诊断程序，还有大量的应用程序…其中最重要的是核心系统软件——操作系统。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B1%82.png" alt="计算机系统的软件层"></li>
<li><strong>操作系统的特性</strong>
<ul>
<li><strong>并发</strong><br>
并行性，又称共行性，是指能处理多个同时性活动的能力。单机操作系统的并行性，又称为并发性。单机上可以有多个同时性活动，它们在CPU和各种不同的IO设备上可以同时操作，但在CPU的执行上只能顺序地执行，这种并行称为逻辑上的并行。</li>
<li><strong>共享</strong><br>
多个计算任务对系统资源的共同享用。对信息资源的共享还需要提供保护手段，如实施存取控制等措施，以保证信息资源的安全。</li>
<li><strong>不确定性</strong><br>
操作系统能处理随即发生的多个事件，这些事件的产生是随机的，而且先后次序也有多种可能，操作系统可以处理各种事件序列，使用户的各种计算任务正确地完成。</li>
</ul>
</li>
</ol>
</li>
<li><strong>操作系统的基本类型</strong>
<ol>
<li><strong>批量操作系统</strong>
<ul>
<li>定义<br>
批量操作系统将用户提交的作业（包括程序，数据和处理步骤）成批送入计算机，然后由作业调度程序自动选择作业运行。<br>
操作员将一批作业送入系统，计算结果也是成批输出。系统内多道程序同时执行，在作业执行过程中，用户不能直接进行干预。</li>
<li>特点<br>
<code>优点</code>是系统的吞吐率高。只要合理搭配作业，就可以充分利用系统资源。<br>
<code>缺点</code>是作业周转时间较长，用户不能及时了解自己程序地运行情况并加以控制，用户使用计算机十分不方便。</li>
</ul>
</li>
<li><strong>分时操作系统</strong>
<ul>
<li>定义<br>
分时操作系统一般采用时间片轮转的办法，使一台计算机同时为多个终端用户服务。</li>
<li>特点
<ul>
<li><code>并行性</code><br>
共享一台计算机的众多联机用户可以在各自的终端上同时处理自己的程序</li>
<li><code>独占性</code><br>
每个用户的感觉是自己独占计算机。</li>
<li><code>交互性</code><br>
用户与计算机之间可以进行交互会话，直到全部工作完成。</li>
</ul>
</li>
</ul>
</li>
<li><strong>实时操作系统</strong>
<ul>
<li>定义<br>
能在规定时间内处理完毕，并对外部输入的信息做出反应。</li>
<li>特点
<ul>
<li>实时响应</li>
<li>高可靠性和安全性，系统效率放在第二位</li>
<li>实时操作系统的终端设备通常只是作为执行装置或咨询装置，不允许用户通过实时终端设备去编写新的程序或修改已有的程序。</li>
</ul>
</li>
</ul>
</li>
<li><strong>个人计算机操作系统</strong><br>
图形用户界面的<strong>视窗操作系统(Windows)</strong>; <strong>UNIX系统</strong>和<strong>Linux系统</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="二、操作系统的结构和硬件支持"><strong>二、操作系统的结构和硬件支持</strong></h2>
<ol>
<li><strong>操作系统虚拟机</strong><br>
裸机+操作系统构成了操作系统虚拟机。
<ol>
<li><strong>操作命令</strong>
<ul>
<li>键盘命令</li>
<li>作业控制语言</li>
<li>图形化用户界面</li>
</ul>
</li>
<li><strong>系统功能调用</strong><br>
在用户程序中可以直接使用系统功能调用请求操作系统提供的服务。</li>
</ol>
</li>
<li><strong>操作系统的组织结构</strong>
<ol>
<li><strong>操作系统的结构</strong><br>
<code>一体化结构</code>，<code>模块化结构</code>，<code>可扩展内核结构</code>和<code>层次化结构</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="操作系统的四种组织结构示意图">
<ol>
<li><code>单体结构</code><br>
操作系统是一组过程的集合，每一过程都有一个定义好的接口，包括入口参数和返回值。</li>
<li><code>模块化结构</code><br>
采用模块化结构的系统，其功能是通过逻辑独立的模块来划分，相关模块间具有良好定义的接口，模块需要封装，数据抽象允许模块隐藏数据结构的实现细节。</li>
<li><code>可扩展内核结构</code><br>
可扩展内核结构将操作系统内核分为基础核心和其他核心功能两部分，基础核心包括公共必须的基本功能集合。<br>
在<strong>现代操作系统</strong>中，常采取机制与策略分离的方法，对实现操作系统的灵活性有十分重要的意义。</li>
<li><code>层次结构</code><br>
操作系统由若干层组成，每一层提供一套功能，并且该功能仅仅依赖于该层以内的各层，最终结构与洋葱头相似。</li>
</ol>
</li>
<li><strong>运行时的组织结构</strong><br>
在操作系统运行过程中调用一个给定的操作系统的内部例程有两种方式
<ul>
<li>系统功能调用<br>
将操作系统服务作为子例程来提供。应用程序需要操作系统某个服务功能时，只需调用对应的内核功能或库函数即可。</li>
<li>客户/服务器方式<br>
将操作系统服务作为系统服务进程来提供，服务请求和服务响应是通过消息传递方式来实现的。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png" alt="操作系统运行时的组织结构">
<ul>
<li><code>优点：</code>
<ul>
<li>适用于分布式系统</li>
<li>便于实现多种不同的服务类型</li>
<li>具有较好的容错性</li>
<li>C/S组织方式严格进行了功能性的分离</li>
</ul>
</li>
<li><code>缺点</code>
<ul>
<li>操作系统必须维持许多持久型的服务进程，这些进程要监听和响应各种不同的请求</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>操作系统与计算机系统各层次的接口</strong><br>
操作系统处在计算机系统中的硬件层和其他所有软件之间的位置，它与硬件、应用程序和用户都有接口。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%85%B7%E6%9C%89%E4%B8%80%E4%BD%93%E5%8C%96%E7%BB%93%E6%9E%84%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8E%A5%E5%8F%A3.png" alt="具有一体化结构的操作系统提供的接口"><br>
操作系统的最低层和硬件接口，它包含CPU提供的机器指令。操作系统的程序代码被编译成机器指令并运行在裸机上。操作系统要为上层软件和用户程序提供用户接口，用户以受控方式请求操作系统提供的服务；另外操作系统必须响应系统运行时的并发事件，需要两种硬件机制提供的支持，这两种硬件机制是：
<ul>
<li>处理机的不同状态</li>
<li>中断和陷入<br>
操作系统的<strong>用户接口</strong>包括<strong>程序接口</strong>和<strong>操作接口</strong>。</li>
<li>程序接口<br>
供用户程序和系统库使用。</li>
<li>操作接口<br>
用户可以通过操作接口控制和处理程序的运行，这一操作接口通过操作系统提供的命令处理程序来实现。</li>
</ul>
</li>
</ol>
</li>
<li><strong>处理机的特权级</strong>
<ol>
<li><strong>处理机的态及分类</strong><br>
计算机系统中有着大量程序，可以分为两类：<code>操作系统的管理程序</code>和<code>用户程序</code>。<br>
程序在处理机上执行时，二者职责不同，权限也不同。根据对资源和机器指令的使用权限，将处理执行时的工作状态区分为不同的态。<br>
态又称处理机的特权级。为了保护操作系统，至少区分两种状态：<code>管态</code>和<code>用户态</code>
<ul>
<li><strong>管态(Supervisor Mode)</strong><br>
又称为系统态，是操作系统的管理程序执行时机器所处的状态。在此状态下中央处理机可以使用全部机器指令，包括一组特权指令，可以使用所有资源，允许访问整个存储区。</li>
<li><strong>用户态(User Mode)</strong><br>
又称为目态，用户程序执行时机器所处的状态。在此状态下禁止使用特权指令，不能直接取用资源与改变机器状态，并且只允许用户程序访问自己的存储区域。<br>
有的系统还把管理程序执行时的机器状态分为<code>核态(Kernel)</code>和<code>管态</code>。管态权限小于核态，用户态更小。<br>
状态寄存器种要设置一个系统状态位，或称模式位来区分处理机的工作状态。</li>
</ul>
</li>
<li><strong>特权指令</strong><br>
特权指令涉及如下几个方面：
<ul>
<li>改变机器状态的指令</li>
<li>修改特殊寄存器的指令</li>
<li>设计外部设备的输入/输出指令<br>
在下列情况下，由用户态自动转向管态：</li>
<li>用户进程访问操作系统，要求操作系统的某种服务，这种访问称为系统功能调用</li>
<li>在用户进程执行时，发生一次中断（如I/O完成中断）</li>
<li>在一个用户进程中产生一个错误状态，这种状态被处理为程序性中断</li>
<li>在用户态下企图执行一条特权指令，作为一种特殊类型的错误，并按情况3处理</li>
</ul>
</li>
</ol>
</li>
<li><strong>中断及其处理</strong>
<ol>
<li><strong>中断概念及类型</strong>
<ol>
<li><strong>中断概念</strong><br>
所谓中断，是指某个事件发生时，系统中止现行程序的运行、引出处理该事件的程序进行处理，处理完毕后返回断点，继续执行。<br>
整个中断过程涉及用户程序和操作系统的中断程序这两类程序。整个过程包括由硬件实现的中断进入、软件的中断处理过程、中断返回这几个步骤。而中断过程是由一个中断信号引发的。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%B8%AD%E6%96%AD%E6%A6%82%E5%BF%B5.png" alt="中断概念"></li>
<li><strong>中断类型</strong>
<ol>
<li><code>按中断功能分类</code>
<ul>
<li>输入输出中断<br>
当外部设备或通道操作正常结束或发生某种错误时发生的中断。</li>
<li>外中断<br>
对某台中央处理机而言，它的外部非通道式装置所引起的中断称为外部中断</li>
<li>机器故障中断<br>
机器发生故障时所产生的中断称为硬件故障中断。</li>
<li>程序性中断<br>
在现行程序执行过程中，发现了程序性质的错误或出现了某些程序的特定状态而产生的中断称为程序性中断。</li>
<li>访管中断<br>
对操作系统提出某种需求时所发出的中断称为访管中断。</li>
</ul>
</li>
<li><code>按中断方式分类</code>
<ul>
<li>强迫性中断<br>
由某种事故或外部请求信号所引起的</li>
<li>自愿中断<br>
运行程序所期待的事件，这种事件是由于运行程序请求操作系统服务而引起的。</li>
</ul>
</li>
<li><code>按中断来源分类</code>
<ul>
<li>中断<br>
由处理机外部事件引起的中断称为外中断，又称中断，在x86中称为异步中断，它是随CPU的时钟随机产生的，可能发生在一条指令执行过程中，也可能发生在一条指令执行后。</li>
<li>俘获（异常）<br>
处理机内部事件引起的中断称为俘获，在x86中称为异常，也称同步中断，包括访管中断、程序性中断、机器故障中断。同步终端指的是由CPU控制单元产生，是在一条指令执行完毕后才会发出中断。<br>
俘获总是优先得到响应和处理，所以它也称为高优先级中断。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%BF%98%E8%8E%B7.png" alt="中断与俘获"></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>向量中断和探询中断</strong>
<ul>
<li>向量中断<br>
由于对应每一个中断都有一个独特的标识，所以不需要再经过分析就可直接转到处理该中断的处理程序。</li>
<li>探询中断<br>
将系统中的所有中断类型分为几大类，每一大类中都包含若干个中断类型。产生一个中断信号时，在探询中断机制下，由中断响应转入的是某一大类中断的处理程序入口。</li>
</ul>
</li>
<li><strong>中断进入</strong>
<ol>
<li>
<p><code>保护现场和恢复现场</code><br>
现场信息包括：</p>
<ul>
<li>后继指令所在的主存单元号</li>
<li>程序运行所处的状态（用户态或管态）</li>
<li>指令执行情况以及程序执行的中间结果</li>
<li>等等<br>
中断发生时，必须立即把现场信息保存在主存中。<br>
程序运行之前，把保留的该程序现场信息从主存中送至相应的指令计数器、通用寄存器或一些特殊的寄存器中。完成这些工作称为恢复现场。</li>
</ul>
</li>
<li>
<p><code>程序状态字</code><br>
程序状态字是反映程序执行时机器所处的现行状态的代码。</p>
<ul>
<li>程序当前应执行的指令</li>
<li>当前指令执行情况</li>
<li>处理机所处的状态</li>
<li>程序在执行时应屏蔽的中断</li>
<li>寻址方法、编址、保护键</li>
<li>响应中断的内容</li>
</ul>
</li>
<li>
<p><code>中断响应</code><br>
发生中断事件时，终端系统必须立即将程序状态字寄存器的内容存放到主存约定单元保存，然后会存放到被打断的程序对应的 <strong>进程控制块(PCB)</strong> 中以备以后需要返回原来被中断的程序时，用它来重新设置指令计数器和处理器状态寄存器，使被终端的程序返回断电继续执行。<br>
中断响应的实质是交换<code>用户程序</code>和处理该中断事件的中断处理程序的<code>指令执行地址和处理器状态</code>，以达到如下目的：</p>
<ul>
<li>保留程序断点及有关信息</li>
<li>自动转入相应的中断处理程序执行<br>
中断响应所需的硬件支持包括<strong>指令计数器</strong>、<strong>处理器状态寄存器</strong>、<strong>中断向量表和系统堆栈</strong></li>
</ul>
<blockquote>
<p>example</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="中断响应的过程"></p>
</li>
</ol>
</li>
<li><strong>软件中断处理过程</strong><br>
硬件完成了中断响应后，相应的中断处理程序得到控制权，进入软件的中断处理：
<ul>
<li>保护现场和传递参数</li>
<li>执行相应的中断（或自陷）服务例程</li>
<li>恢复和退出中断<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="中断处理过程"></li>
</ul>
<ol>
<li><code>硬件故障中断的处理</code><br>
操作系统一般只是保护现场，防止故障蔓延，向操作员报告并提供故障信息。</li>
<li><code>程序性中断事件的处理</code>
<ul>
<li>程序错误而又难以克服的事件<br>
操作系统只能将出错的程序名，出错地点和错误性质报告给操作员</li>
<li>其他一些程序性中断事件<br>
操作系统可以将这些程序性中断事件交给用户程序，让它自行处理。</li>
</ul>
</li>
<li><code>外部中断事件的处理</code><br>
外部中断是由外部非通道式装置所引起的中断。
<ul>
<li>时钟中断事件的处理<br>
时钟中断处理程序叫醒被延迟的进程</li>
<li>控制台中断事件的处理<br>
通过控制台开关产生中断事件通知操作系统</li>
</ul>
</li>
<li><code>外部设备中断的处理（P48）</code>
<ul>
<li>传输结束中断的处理</li>
<li>传输错误中断的处理</li>
<li>故障中断的处理</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="三、操作系统用户接口"><strong>三、操作系统用户接口</strong></h2>
<ol>
<li><strong>用户工作环境</strong><br>
不同操作系统具有能满足不同应用需求的用户工作环境
<ol>
<li><strong>操作系统提供的环境</strong>
<ul>
<li>提供各种软硬件资源</li>
<li>设计操作系统的命令集</li>
<li>当用户需要的时候，激活操作系统，使它成为一个可以提供服务的系统</li>
</ul>
</li>
<li><strong>操作系统的生成和系统初启</strong>
<ol>
<li><code>系统生成</code><br>
操作系统的生成是形成一个满足用户需要的操作系统的过程。<br>
系统生成包括：根据硬件部件确定系统构造的参数，编辑系统模块的参数，并且连接系统的目标模块成为一个可执行的程序。<br>
系统生成过程中，必须确定以下信息。
<ul>
<li>使用的CPU类型</li>
<li>可用主存空间</li>
<li>可用的设备</li>
<li>所需的操作系统选项和参数值</li>
</ul>
</li>
<li><code>系统初启</code><br>
系统生成后，以文件形式存储在某种存储介质中。这是一个可执行的目标代码文件，由C语言和少量汇编语言程序经过编译、连接而形成的。
<ul>
<li>系统引导<br>
系统初启又叫系统引导。将操作系统的必要部分装入主存并使系统运行，最终处于命令接收状态。<br>
系统引导分为三个阶段：
<ul>
<li><strong>初始引导</strong>：把系统核心装入主存中的指定位置，并在指定地址启动</li>
<li><strong>核心初始化</strong>：执行系统核心的初启子程序，初始化系统核心数据</li>
<li><strong>系统初始化</strong>：为用户使用系统做准备</li>
</ul>
</li>
<li>系统引导的方式<br>
系统引导有两种方式：<strong>独立引导(bootup)<strong>和</strong>辅助下装(download)</strong>
<ul>
<li>独立引导方式<br>
又称滚雪球方式，适用于微机和大多数系统。由系统自己将操作系统核心程序读入主存并运行，最后建立一个操作系统</li>
<li>辅助下装方式<br>
适用于多计算机系统，由主控机与前端机构成的系统以及分布式系统。</li>
</ul>
</li>
</ul>
</li>
<li><code>独立引导的过程</code>
<ul>
<li><em>初始引导</em><br>
也叫自举。自举是操作系统通过滚雪球的方式将自己建立起来。<br>
系统核心是整个操作系统最关键的部分，只有它在主存中运行才能逐步建立起整个系统。初始引导的任务就是把核心送入主存并启动它运行。<br>
步骤如下：
<ul>
<li>系统加电</li>
<li>执行初始引导程序，对系统硬件和配置进行自检，保证系统没有硬件错误</li>
<li>从硬盘中读入操作系统引导程序，并将控制权交给该程序模块</li>
</ul>
</li>
<li><em>引导程序执行</em><br>
引导程序也可以是只负责装入引导装入程序，再由后者装入操作系统。</li>
<li><em>核心初始化</em><br>
操作系统被装入后，核心的初始化程序开始执行，其任务是初始化系统数据结构及参数：
<ul>
<li>建立进程有关的数据结构</li>
<li>获得自由存储空间的容量，建立存储管理的数据结构</li>
<li>建立系统设备和文件系统的数据结构</li>
<li>初始化时钟</li>
</ul>
</li>
<li><em>系统初始化</em><br>
系统初始化的主要任务是做好一切准备工作，使系统处于命令接收状态，使用户可以使用计算机。
<ul>
<li>完善操作系统的工作环境，装载命令处理程序，并初始化</li>
<li>在多用户系统中，为每个终端建立命令解释进程，使系统处于命令接收状态</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><strong>应用程序的处理</strong>
<ol>
<li><code>处理用户程序的步骤</code>
<ul>
<li>编辑<br>
建立一个新文件，或对已有的文件中的错误进行修改</li>
<li>编译<br>
为源程序翻译成浮动的目标代码</li>
<li>连接<br>
将主程序和其他所需要的子程序和例行程序连接装配在一起，使之成为一个可执行的、完整的主存映像文件</li>
<li>运行<br>
将主存映像文件调入主存，并启动运行，最后得出计算结果<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4.png" alt="一个应用程序的处理步骤"></li>
</ul>
</li>
<li><code>静态链接和动态链接</code>
<ul>
<li>静态链接<br>
将所有外部调用函数都连接到目标文件中形成一个完整的主存映像文件。会造成主存极大浪费。</li>
<li>动态链接<br>
动态链接是将这一连接工作延迟到程序运行的时候进行，所需要的支持是动态链接库(Dynamic Link Library, DLL)。在应用程序需要调用外部函数的地方做记录，并说明要使用的外部函数名和引用入口号，形成调用链表。现在的动态链接库一般是系统库。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>用户接口</strong>
<ol>
<li><strong>用户接口的定义</strong><br>
操作系统的用户接口分为两个方面：
<ul>
<li>是操作接口，用户通过这个操作接口来组织自己的工作流程和控制程序的运行</li>
<li>是程序接口，任何一个用户程序在其运行过程中，可以使用操作系统提供的功能调用来请求操作系统的服务。<br>
现代操作系统还提供图形化的用户界面和 <strong>用户程序编程接口(Application Programming Interface, API)</strong> 这是传统操作接口和系统功能服务界面在现代操作系统的体现。</li>
</ul>
</li>
<li><strong>操作系统提供的用户接口</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3.png" alt="操作系统提供的用户接口">
<ol>
<li><code>操作接口</code><br>
对于操作接口而言，其形式取决于操作系统的类型。
<ul>
<li>键盘命令<br>
一般终端与主机通信的过程可以分为<code>注册</code>，<code>通信</code>，<code>注册</code>三个步骤
<ul>
<li>注册<br>
注册的目的有两个，<strong>让系统验证你有无限使用该系统的权限</strong>，<strong>让系统为你设置必要的环境</strong></li>
<li>通信<br>
属于这一步的键盘命令非常丰富
<ul>
<li>文件管理</li>
<li>编辑修改</li>
<li>编译、连接装配和运行</li>
<li>输入数据</li>
<li>操作方式转换</li>
<li>申请资源</li>
</ul>
</li>
<li>注销</li>
</ul>
</li>
<li>图形化用户界面
<ul>
<li>菜单驱动方式</li>
<li>图符驱动方式</li>
</ul>
</li>
</ul>
</li>
<li><code>程序接口</code><br>
操作系统和用户的第二个接口是系统功能调用，它是管理程序提供的服务界面，更确切地说，是程序设计语言中增加的操作系统提供服务的语言表示。</li>
</ol>
</li>
</ol>
</li>
<li><strong>系统功能调用</strong>
<ol>
<li><strong>系统功能调用的定义</strong><br>
在操作系统设计时，就确定和编制好能实现这些功能的例行子程序，他们属于操作系统的内核模块。<br>
为了实现对这些事先编制好的、具有特定功能的例行子程序的调用，现代计算机系统提供自愿进管指令，其指令的一般形式为：<code>svc n</code>svc 是 supervisor call(访问管理程序)的缩写，所以svc指令又称访管指令。
<ul>
<li><strong>系统功能</strong>调用是操作系统提供的程序接口，是操作系统命令集中的一部分</li>
<li><strong>访管指令</strong>是一条机器指令，是裸机提供的接口。一个带有一定功能号的访管指令定义了一个系统调用。系统调用是利用“访管指令”定义的命令。</li>
</ul>
</li>
<li><strong>系统功能调用的实现</strong><br>
操做系统的服务是通过系统调用来实现的，系统调用提供运行程序和操作系统之间的接口。实际上这种服务是由系统服务请求机构提供的，<strong>系统服务请求机构(System Service Request, SSR)</strong> 本质是一个 <strong>自陷门(Trap Door)</strong>。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="系统调用的执行过程"></li>
<li><strong>应用程序地编程接口</strong><br>
应用程序通过操作系统提供的程序接口请求操作系统的服务、访问各类资源。一般情况下，应用程序通过API来请求操作系统服务。<br>
系统调用与库函数有区别，库函数由软件开发商提供，系统调用代码属于OS。</li>
</ol>
</li>
</ol>
<hr>
<h2 id="四、进程及进程管理"><strong>四、进程及进程管理</strong></h2>
<ol>
<li><strong>进程引入</strong>
<ol>
<li><strong>顺序程序及特点</strong>
<ol>
<li><code>程序与计算</code><br>
用来表示人们思维对象的抽象概念的物理表现叫做“数据”，可以在人与人，人与计算机之间传递信息。<br>
数据处理的规则叫做<code>操作</code>。<br>
<code>程序</code>是为解决某一问题而设计的一系列指令的集合，是算法的形式化描述。</li>
<li><code>什么是程序的顺序执行</code><br>
一个计算由若干个操作组成，若这些操作必须按照某种先后次序来执行，以保证操作的结果是正确的。</li>
<li><code>顺序程序的特点</code>
<ul>
<li>顺序性<br>
一个接一个地以有限的速度进行的</li>
<li>封闭性<br>
程序一旦开始执行，其计算结果不受外界因素的影响</li>
<li>可再现性<br>
程序执行地结果与它的执行速度无关（即与事件无关），只与初始条件有关。</li>
</ul>
</li>
</ol>
</li>
<li><strong>并发程序及特点</strong>
<ol>
<li><code>什么是程序的并发执行</code><br>
I(Input), C(Calculate), P(Print)分别占用不同资源，可并行。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%A4%9A%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%88%E5%90%8E%E6%AC%A1%E5%BA%8F.png" alt="多用户系统中操作的先后次序"></li>
<li><code>并发程序的特点</code><br>
程序的并发执行提高了系统的处理能力和计算机的利用率。
<ul>
<li>失去程序的封闭性<br>
如果一个程序的执行可以改变另一个程序的变量，那么后者的输出就可能有赖于这两个程序执行的相对速度，也就是失去了程序的封闭性特点。<br>
计算结果与并发程序执行的速度有关，也就是说，并发程序已失去了顺序程序的封闭性的特点。</li>
<li>程序与计算不再一一对应<br>
程序是静态概念，计算是动态概念。并发执行时，程序与计算一一对应的关系就不存在了。当多个计算任务共享某个程序时，他们都可以调用这个程序。</li>
<li>程序并发执行时的相互制约关系<br>
从图4.2可知，程序并发执行时有点拓扑的意思，有一定的逻辑联系。</li>
</ul>
</li>
<li><code>与时间有关的错误</code><br>
程序并发执行时，系统处于一个复杂的动态组合状态，各程序执行的相对速度不定，若并发程序重复执行，程序员不容易看到两个同样的结果。</li>
</ol>
</li>
</ol>
</li>
<li><strong>进程概念</strong>
<ol>
<li><strong>进程的定义</strong><br>
程序的并发执行指的是多个程序都处于已经开始，但都未执行完毕的状态中。人们引入新的概念——进程，以便从变化的角度，动态地分析研究并发程序的活动。<br>
为了描述进程，人们将状态信息和与进程有关的信息组织成一个数据结构——<strong>进程控制块(Process Control Block, PCB)</strong>。<br>
进程与程序的区别：
<ul>
<li>程序是指令的有序集合，是一个静态概念，其本身没有任何运行的含义。</li>
<li>进程是一个能独立运行的单位，能与其他进程并行地活动。</li>
<li>进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。</li>
</ul>
</li>
<li><strong>进程的状态及变迁</strong>
<ol>
<li><code>进程地基本状态</code>
<ul>
<li>就绪状态(Ready)<br>
获得除CPU之外所有的资源</li>
<li>运行状态(Running)<br>
正在处理机上运行</li>
<li>等待状态/阻塞状态(Wait)<br>
进程正在等待某一事件发生而暂时停止执行。</li>
</ul>
</li>
<li><code>进程状态变迁图</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%85%B7%E6%9C%89%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E7%9A%84%E5%8F%98%E8%BF%81%E5%9B%BE.png" alt="具有进程基本状态地变迁图"></li>
</ol>
</li>
<li><strong>进程控制块</strong>
<ol>
<li><code>什么是进程控制块</code><br>
当系统创建一个进程时，必须为它设置一个PCB，然后根据PCB的信息对进程实施控制和管理。进程任务完成时，<strong>系统撤销它的PCB</strong>，<strong>进程也随之消亡</strong>。
<ul>
<li>进程标识符(ID号)</li>
<li>进程的状态(ready, running, wait)</li>
<li>当前队列指针next<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%BF%9B%E7%A8%8B%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84.png" alt="进程队列结构"></li>
<li>进程优先级priority</li>
<li>CPU现场保护区cpustatus</li>
<li>通信信息communication information</li>
<li>家族联系process family</li>
<li>占有资源清单own_resource</li>
</ul>
</li>
<li><code>进程的组成</code><br>
任务（或进程）是由一个程序以及与它相关的状态信息（包括寄存器内容、存储区域和链接表）所组成的。<br>
从结构上说，每个进程都由一个程序段（包括数据）和一个进程控制块PCB组成。<br>
程序和数据描述进程本身应完成的功能；进程控制块PCB则描述进程的动态特征、进程与其他进程和系统资源的关系。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90.png" alt="进程的组成"></li>
</ol>
</li>
</ol>
</li>
<li><strong>进程控制</strong>
<ol>
<li><strong>进程控制的概念</strong><br>
进程控制原语：创建原语、撤消原语、等待原语、唤醒原语。</li>
<li><strong>进程创建与撤销</strong>
<ol>
<li><code>进程创建</code><br>
系统初启时，创建并产生一些必需的、承担系统资源分配和管理工作的系统进程。<br>
<strong>批处理系统</strong>中，由操作系统的作业调度程序负责创建进程。<br>
<strong>分时系统</strong>中，由命令处理程序（如UNIX或Linux系统的shell）负责创建。<br>
进程能创建子进程。<br>
<code>create(name, priority)</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA.png" alt="进程创建"><br>
PCB资源池是PCB集合，是系统内核区中的一个结构数组，用来存放进程控制块。系统初始化时，PCB结构中进程标识符单元内存放“-1”，表示该PCB结构为空。当创建原语执行成功后，该项内容为新创建进程的标识符。</li>
<li><code>进程撤销</code><br>
撤销本进程、撤销一个指定标识符的进程或撤销一组子进程，后面两个只能用于父进程撤销子进程。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%BF%9B%E7%A8%8B%E6%92%A4%E9%94%80.png" alt="进程撤销"></li>
</ol>
</li>
<li><strong>进程等待与唤醒</strong>
<ol>
<li><code>进程等待</code><br>
<code>susp(chan)</code>，chan：进程等待的原因。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%851.png" alt="进程等待"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%852.png" alt="进程等待"></li>
<li><code>进程唤醒</code><br>
<code>wakeup(chan)</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%BF%9B%E7%A8%8B%E5%94%A4%E9%86%92.png" alt="进程唤醒"></li>
</ol>
</li>
</ol>
</li>
<li><strong>进程之间的约束关系</strong>
<ol>
<li><strong>进程竞争与合作</strong>
<ol>
<li><code>竞争系统资源</code><br>
进程共享系统资源，它们对共享资源的使用是通过操作系统的资源管理程序来协调的。<br>
需要使用共享资源的进程，先向系统提出申请，然后由资源管理程序根据资源情况，按一定的策略来实施分配。</li>
<li><code>进程协作</code><br>
进程之间存在有共享数据时，将引起直接的相互制约的关系。进程之间共享了某些资源，为了保证数据完整性，需要正确地处理进程协作的问题。<br>
解决进程写作问题的方法是操作系统提供同步机构。各进程利用同步机构来使用共享数据，从而实现正确的协作。(eg:PV信号灯，互斥锁等)
<ul>
<li>信息共享<br>
操作系统提供支持，允许对这些资源类型的并发访问。</li>
<li>并行处理<br>
协调进程之间的直接相互制约关系就是要协调各进程前进的步伐，即实现进程的同步。要实现进程同步，必须支持进程间的信息传递。<br>
进程同步可细分为：进程互斥、进程同步和进程的直接通信。</li>
</ul>
</li>
</ol>
</li>
<li><strong>进程互斥的概念</strong>
<ol>
<li><code>临界资源</code><br>
系统中有多个进程，他们共享各种资源，有些资源一次只能为一个进程所使用。<br>
通常把一次仅允许一个进程使用的资源称为临界资源。</li>
<li><code>临界区</code><br>
一组进程共享某一临界资源，这组进程中的每一个进程对应的程序中都包含了一个访问该临界资源的程序段。每个进程中，访问该临界资源的那段程序能够从概念上分离出来，称为<strong>临界区</strong> 或 <strong>临界段</strong></li>
<li><code>互斥</code><br>
当某一进程正在访问某一存储区域时，不允许其他进程来读出或者修改存储区的内容。</li>
</ol>
</li>
<li><strong>进程同步的概念</strong>
<ol>
<li><code>什么是同步</code><br>
并发进程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程同步。</li>
<li><code>同步的例子</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%90%8C%E6%AD%A5%E5%85%B3%E7%B3%BB.png" alt="看病进程与化验进程的同步关系"><br>
<strong>生产者消费者</strong>
<ul>
<li>当CP把数据送入buf时，IOP才能从buf中取出数据去打印</li>
<li>当IOP把buf中数据取出时，CP才能把下一个数据送入buf中<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E7%BC%93%E5%86%B2%E5%8C%BA%E5%90%8C%E6%AD%A5.png" alt="打印共享缓冲区同步"></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>同步机构</strong>
<ul>
<li>锁和上锁、开锁操作</li>
<li>信号灯和P、V操作</li>
</ul>
<ol>
<li>
<p><strong>锁和上锁、开锁操作</strong><br>
共享的临界资源都要有一个单独的锁位。<code>&quot;0&quot;</code>表示资源可用，<code>&quot;1&quot;</code>表示资源已被占用</p>
<ul>
<li>检测锁位的值（是0还是1）</li>
<li>如果原来的值为0，将锁位置为1（表示占用资源）</li>
<li>如果原来的值为1（资源已被占用），则返回第一步再考察<br>
一个锁位w上的两个原语操作<code>lock(w)</code>和<code>unlock(w)</code></li>
</ul>
<blockquote>
<p>初步</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%B8%8A%E9%94%81%E5%BC%80%E9%94%81.png" alt="上锁开锁"><br>
<code>lock(w)</code>原语的进程可能要循环测试而占用处理及时间（称为“忙等待”）</p>
<blockquote>
<p>改进</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E6%94%B9%E8%BF%9B%E7%89%88.png" alt="改进版"></p>
</li>
<li>
<p><strong>信号灯和P、V操作</strong></p>
<ol>
<li><code>信号灯</code><br>
信号灯是一个确定的二元组<code>(s, q)</code>, <code>s</code>是一个具有非负初值的整型变量，<code>q</code>是一个初始状态为空的队列
<ul>
<li><strong>信号灯的值大于或等于0时</strong>，表示绿灯进程可以继续推进。</li>
<li><strong>信号灯的值小于零时</strong>，表示红灯，进程被阻。</li>
</ul>
</li>
<li><code>P、V操作</code>
<ul>
<li><strong>P操作</strong><br>
P(s)是一个不可分割的原语操作，即信号灯值-1，若相减结果为负，则调用P(s)的进程被阻，并插入该信号灯的等待队列中，否则可以继续执行。
<ul>
<li>s-1</li>
<li>(s - 1) &gt;= 0 -&gt; 继续</li>
<li>(s - 1) &lt; 0 -&gt; 插入到信号灯等待队列中<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/P.png" alt="P"></li>
</ul>
</li>
<li><strong>V操作</strong><br>
V(s)是一个不可分割的原语操作，即信号灯值+1，若相加结果 &gt; 0, 进程继续执行，否则，唤醒在信号灯等待队列上的一个进程。
<ul>
<li>s + 1</li>
<li>(s + 1) &gt; 0 -&gt; 继续</li>
<li>(s + 1) &lt;= 0 -&gt; 从信号灯的等待队列中移出一个进程，解除它的等待状态，然后返回本进程继续执行。<br>
<strong>算法  V</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/V.png" alt="V"></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>进程互斥与同步的实现</strong>
<ol>
<li><strong>上锁原语和开锁原语实现进程互斥</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%BD%BF%E7%94%A8%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4.png" alt="操作步骤"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%BA%92%E6%96%A5%E9%94%81.png" alt="互斥锁"></li>
<li><strong>信号灯实现进程互斥</strong>
<ul>
<li>设置互斥信号灯，一般记为mutex(mutual exclusion的缩写)，赋初值为1</li>
<li>将进入临界区的操作置于P(mutex)和V(mutex)之间，即可实现进程互斥。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%BF%A1%E5%8F%B7%E7%81%AF%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5.png" alt="信号灯实现进程互斥"></li>
</ul>
</li>
<li><strong>进程同步的实现</strong><br>
病原就诊的例子：
<ul>
<li>看病进程开出化验单，发送给化验进程，化验进程才能工作，否则化验进程必须等待</li>
<li>化验进程化验完毕得到化验结果，并发送给看病进程，看病进程才能根据化验结果确定医疗方案，否则看病进程必须等待<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5.png" alt="进程同步"></li>
</ul>
<ol>
<li><code>合作进程的执行次序</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%BF%9B%E7%A8%8B%E6%B5%81%E5%9B%BE.png" alt="进程流图"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/task4.png" alt="task4"></li>
<li><code>共享缓冲区的合作进程的同步</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/task5.png" alt="task5"></li>
</ol>
</li>
<li><strong>生产者——消费者问题</strong><br>
一群生产者<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>p</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">p_1,p_2,...p_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和一群消费者<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>c</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>c</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">c_1,c_2,...c_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>共享一个有界缓冲区。只要缓冲区未满生产者就可以把产品送入缓冲区。<br>
为解决这一类问题，应设置两个同步信号灯：
<ul>
<li><code>空缓冲区的数目(empty)</code></li>
<li><code>满缓冲区的数目(full)</code></li>
<li><code>设置一个互斥信号灯(mutex)</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/pc1.png" alt="prod_cons"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/pc2.png" alt="prod_cons"></li>
</ul>
</li>
</ol>
</li>
<li><strong>进程通信</strong>
<ol>
<li><strong>进程通信的概念</strong><br>
操作系统提供锁和信号灯这些同步机构可以达到协调同步的目的，特点是：
<ul>
<li>装置限制为一个单一的信息</li>
<li>利用这种同步机构实现的进程同步是通过共享存储器来实现的</li>
<li>较低级，间接的通信方式</li>
</ul>
</li>
<li><strong>进程通信方式</strong><br>
进程通信(Interprocess Communication, IPC)是一个进程与另一个进程间共享消息的一种方式。消息(message)是发送进程形成的一个信息块。<br>
一个用户程序执行时只能在自己的存储空间范围内访问，不能进入另一个用户的存储空间。上述的消息传递只能通过操作系统提供的支持才能实现，这就是IPC机制。
<ol>
<li><code>消息缓冲通信</code><br>
消息缓冲通信方式包括<code>消息缓冲</code>、<code>发送原语</code>和<code>接收原语</code>。<br>
形成一个消息缓冲区，用发送原语把消息发送出去。</li>
<li><code>信箱通信</code><br>
信箱通信中，除了定义信箱结构外，还包括<strong>消息发送</strong>和<strong>接收功能</strong>模块，提供<strong>发送原语</strong>和<strong>接收原语</strong>。<br>
接收进程有可能覆盖信箱的部分内容，从而导致错误发生。<br>
信箱在接收进程的地址空间中。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%BF%A1%E7%AE%B1%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.png" alt="信箱实现消息传递"><br>
在操作系统空间中存放接收进程的信箱，消息的拷贝在接收进程发出接收消息的系统调用时进行。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E7%B3%BB%E7%BB%9F%E7%A9%BA%E9%97%B4%E4%BF%A1%E7%AE%B1%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.png" alt="系统空间信箱实现消息传递"></li>
</ol>
</li>
</ol>
</li>
<li><strong>线程概念及特点</strong>
<ol>
<li><strong>线程的概念</strong><br>
<code>线程(thread)</code>，在操作系统中，为了支持并发活动，引入了线程的概念。在现代操作系统中，提供了对单个进程中多条控制线索的支持。这些控制线索通常称为<strong>线程(threads)</strong>，有时也叫<strong>轻量级进程(lightweight processes)</strong></li>
</ol>
</li>
</ol>
<hr>
<h2 id="五、资源分配与调度"><strong>五、资源分配与调度</strong></h2>
<ol>
<li><strong>资源管理概述</strong>
<ol>
<li><strong>资源管理的目的和任务</strong><br>
操作系统提供资源、满足用户请求的“服务员”，资源是被存取的对象。服务员就是<strong>资源管理程序</strong>。
<ol>
<li><code>资源的静态分配和动态分配</code>
<ul>
<li><code>静态分配</code>作业所需要的资源是在这个作业被调度时，根据用户给出的信息进行分配，并在作业运行完毕后释放所获得的全部资源。</li>
<li><code>动态分配</code>进程所需要的资源是在进程运行中根据运行情况动态地分配、使用和释放的。</li>
</ul>
</li>
<li><code>资源管理的任务</code>
<ul>
<li>资源数据结构的描述<br>
资源的物理名、逻辑名、类型、地址、分配状态等。</li>
<li>确定资源分配原则和调度原则<br>
需要确定分配原则，以决定资源应分配给谁、何时分配、分配多少等问题。</li>
<li>执行资源分配<br>
根据确定的原则以及用户的要求，执行资源分配。</li>
<li>存取控制和安全保护</li>
</ul>
</li>
</ol>
</li>
<li><strong>虚拟资源</strong><br>
系统提供虚拟资源，似乎每个请求者都可以拥有他所申请的资源。操作系统采用虚拟技术，不仅可以提高资源利用率，实现多用户共享，同时使用户能方便地、简单地使用系统资源。<br>
设备管理要实现虚、实设备的映射。</li>
</ol>
</li>
<li><strong>资源管理的机制和策略</strong>
<ol>
<li><strong>资源分配机制</strong>
<ol>
<li><code>资源描述器</code><br>
<code>rd(resource descriptor)</code>：描述各类资源的最小分配单位的数据结构。<br>
资源描述器描述了资源的特性和该资源的管理方式。有n个资源分配单位则有n个资源描述器。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/rd.png" alt="资源描述器"></li>
<li><code>资源信息块</code><br>
<code>rib(resource information block)</code>：为了对每类资源实施有效的分配，必须设置相应的rib。rib是一个描述<strong>某类资源的请求者</strong>、<strong>可利用的资源</strong>以及<strong>该类资源分配程序的地址</strong>的数据结构。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/rib.png" alt="资源信息块"></li>
</ol>
</li>
<li><strong>资源分配策略</strong>
<ol>
<li><code>先请求先服务</code></li>
<li><code>优先调度</code></li>
<li><code>针对设备特性的调度</code>
<ul>
<li>移臂调度<br>
总是选取与当前移动臂前进方向上最近的那个请求，使移臂距离最短。</li>
<li>旋转调度<br>
旋转调度是指在满足一个磁盘请求时，总是选取与当前读写头旋转方向上最近的那个请求，使旋转圈数最少。</li>
</ul>
</li>
<li><code>几种移臂调度算法</code>
<ul>
<li>最短寻道时间优先算法(SSTF)<br>
从等待访问者中挑选寻找时间最短（与当前磁头位置最近）的那个请求先执行的</li>
<li>扫描算法(SCAN)<br>
扫描算法，又称电梯调度算法。SCAN算法是磁头前进方向上的最短查找时间优先算法。很大程度上消除了SSTF算法的不公平性。<br>
电梯调度算法是从移动臂当前位置开始，沿着臂的移动方向去选择离当前移动臂最近的那个柱面访问者。有点类似于乘电梯规则。
<blockquote>
<p>eg:<br>
cur = 65, wait = 130, 32, 159, 61, 75。<br>
que = 75, 130, 159, 62, 32</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>死锁</strong>
<ol>
<li><strong>死锁的定义与例子</strong><br>
一组进程竞争资源，若资源分配不当，就可能出现互相死等的局面。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E6%AD%BB%E9%94%81eg.png" alt="死锁例子"><br>
生产者——消费者中如果将生产者执行的两个p操作顺序颠倒，死锁情况也可能发生。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/Producer_Consumer.png" alt="Producer_Consumer">
<blockquote>
<p>当缓冲区满时会发生死锁。</p>
</blockquote>
</li>
<li><strong>产生死锁的原因和必要条件</strong>
<ol>
<li><code>产生死锁的原因</code><br>
根本原因是系统能够提供的资源个数比请求该资源的进程数要少。当系统中两个或多个进程因申请资源得不到满足而等待时，若各进程都没有能力进一步执行，系统就发生死锁。
<ul>
<li>系统资源不足</li>
<li>进程推进顺序非法</li>
</ul>
</li>
<li><code>产生死锁的必要条件</code>
<ul>
<li>互斥条件</li>
<li>不剥夺条件（非抢占）</li>
<li>占有并等待（占有并等待）</li>
<li>环路条件（循环等待）</li>
</ul>
</li>
</ol>
</li>
<li><strong>系统模型和死锁的处理</strong>
<ol>
<li><code>资源的申请与释放</code><br>
进程在使用每类资源前必须先申请，使用完毕后应立即释放
<ul>
<li>申请</li>
<li>使用</li>
<li>释放</li>
</ul>
</li>
<li><code>系统状态分析</code><br>
为预防死锁，应能观察系统的情况，以分析某一时刻系统是否处于一个合理的状态。</li>
<li><code>系统资源分配</code><br>
系统资源分配的有向图可以更为精确地描述死锁现象。环是死锁存在的必要条件，而不是充分条件。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%AD%98%E5%9C%A8%E6%AD%BB%E9%94%81%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png" alt="存在死锁的资源分配图"></li>
</ol>
</li>
<li><strong>解决死锁问题的策略</strong><br>
破坏以下四个条件之一
<ol>
<li><code>互斥条件(难以否定)</code></li>
<li><code>不剥夺条件（容易否定但很难实现）</code></li>
<li><code>占有并等待（既容易否定，也容易实现）</code><br>
资源利用率很低</li>
<li><code>环路条件</code></li>
</ol>
</li>
<li><strong>死锁的预防</strong><br>
预防死锁的方法：<code>静态预防</code>和<code>动态避免</code>
<ul>
<li>静态预防一般在应用程序进入系统时进行。预先分配所有共享资源。（缺点：浪费较大）</li>
<li>死锁的避免采用资源的动态分配方法</li>
</ul>
</li>
<li><strong>死锁的避免</strong>
<ol>
<li><code>有序资源分配法</code><br>
为系统中的每一类资源分配唯一的号码。（专门破坏循环等待）
<ul>
<li>必须使用且属于某一类的所有资源必须一次性申请完</li>
<li>申请不同类资源时，必须按各类的编号依次申请。</li>
</ul>
</li>
<li><code>银行家算法</code><br>
有效地避免死锁的算法必须能预见将来可能发生的事情，以便在死锁发生前就能觉察出它的潜在危险。<br>
细节详见（Posts: Linux操作系统）</li>
</ol>
</li>
<li><strong>死锁的检测与忽略</strong><br>
检测死锁的算法比较复杂，所花的检测时间长开销比较大，详见银行家算法地死锁检测部分。</li>
</ol>
</li>
</ol>
<hr>
<h2 id="六、处理机调度"><strong>六、处理机调度</strong></h2>
<ol>
<li><strong>处理机的多级调度</strong>
<ol>
<li><strong>批处理系统中的处理机调度</strong><br>
分为两级：<code>作业调度</code>和<code>进程调度</code>
<ul>
<li>每个用户提交的算题任务，往往作为系统的一个处理单位，称为作业。</li>
<li>一道作业在处理过程中又可以分为多个并发的活动单位，称为进程。<br>
作业调度是宏观调度，作业调度使该作业对应的进程具备使用处理机的权利，而进入主存的诸进程，各在什么时候真正获得处理机，这是由处理及的进程调度来决定的。</li>
</ul>
</li>
<li><strong>多任务操作系统中的处理机调度</strong><br>
系统将用户提交的任务处理为进程，这些进程是动态分配系统资源和处理机的单位。进程调度要完成的任务是当处理机空闲时以某种策略选择一个就绪进程去运行。</li>
<li><strong>多线程操作系统中的处理机调度</strong><br>
系统为进程分配它所需要的资源，而处理机的分配单位则为线程，系统提供线程调度程序。</li>
</ol>
</li>
<li><strong>作业调度</strong>
<ol>
<li><strong>作业的状态</strong>
<ul>
<li>后备状态</li>
<li>执行状态</li>
<li>完成状态<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%BD%9C%E4%B8%9A%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2.png" alt="作业的状态及转换"></li>
</ul>
</li>
<li><strong>作业调度的功能</strong>
<ol>
<li><code>确定数据结构</code><br>
系统为每一个已进入系统的作业分配一个作业控制快jcb(job control block)</li>
<li><code>确定调度算法</code><br>
按一定调度原则从磁盘中选一个投入运行，让作业从后备态转变为执行态。</li>
<li><code>分配资源</code><br>
为被选中的作业分配运行时所需要的系统资源，如主存和外部设备等。</li>
<li><code>善后处理</code><br>
作业执行结束时，作业调度程序输出一些必要的信息，然后收回该作业所占用的全部资源，撤销与其有关的全部进程和作业控制块。</li>
</ol>
</li>
<li><strong>作业控制快</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/jcb.png" alt="jcb"></li>
<li><strong>调度算法性能的衡量</strong>
<ul>
<li>作业的平均周转时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>为<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>t</mi><mi>i</mi></msub><mspace width="2em"/><mspace width="2em"/><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><msub><mi>t</mi><mrow><mi>c</mi><mi>i</mi></mrow></msub><mo>−</mo><msub><mi>t</mi><mrow><mi>s</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">{
t = \frac{1}{n} \sum_{i=1}^n t_i \qquad \qquad t_i = t_{ci} - t_{si}
}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:2em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>为进入系统的作业个数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为作业<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>的周转时间；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{si}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为作业i进入系统的时间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>c</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{ci}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为作业<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>的完成时间。</li>
<li>平均带权周转时间w为<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>w</mi><mi>i</mi></msub><mspace width="2em"/><mspace width="2em"/><msub><mi>w</mi><mi>i</mi></msub><mo>=</mo><mfrac><msub><mi>t</mi><mi>i</mi></msub><msub><mi>t</mi><mrow><mi>r</mi><mi>i</mi></mrow></msub></mfrac></mrow><annotation encoding="application/x-tex">{
    w = \frac{1}{n} \sum_{i=1}^n w_i \qquad \qquad w_i = \frac{t_i}{t_{ri}}
}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:2em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2921em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p>
其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为作业<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>的带权周转时间；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>r</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{ri}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为作业<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>的实际执行时间。<br>
一般来说系统应选择使作业的平均周转时间短的某种算法。因为作业的平均周转时间越短，意味着作业在系统内的停留时间越短，因而系统资源的利用率也就越高。</li>
</ul>
</li>
<li><strong>作业调度算法</strong>
<ol>
<li>
<p><code>FCFS(First Come First Serve)</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/FCFS.png" alt="FCFS"></p>
</li>
<li>
<p><code>SJF(Short Job First)</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/SJF.png" alt="SJF"></p>
</li>
<li>
<p><code>HRRN(Highest Response Ratio Next)</code><br>
即照顾了短作业，又不使长作业的等待时间过长。</p>
 <center> 响应比 = 响应时间/执行时间 </center>
 响应时间为作业进入系统后的等待时间加上估计的执行时间，即为周转时间。
 <center> 响应比 = 1 + 作业等待时间/执行时间 </center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/HRRN.png" alt="HRRN"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/HRRNeg.png" alt="HRRNeg"></p>
</li>
<li>
<p><code>优先调度算法</code><br>
由用户为自己的作业规定一个优先级，优先数反映了用户要求运行的急切程度，系统可对高优先级作业收取高的运算费用。</p>
 <center> 优先数 = 等待时间²- 要求执行时间 - 16×输出量 </center>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>进程调度</strong>
<ol>
<li><strong>调度/分派结构</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%B0%83%E5%BA%A6%E5%88%86%E6%B4%BE%E7%BB%93%E6%9E%84.png" alt="调度分派结构"></li>
<li><strong>进程调度的功能</strong>
<ol>
<li><code>记录进程的有关情况</code><br>
记录进程控制模块通过查询、修改、记录进程控制块PCB结构中有关的数据项的内容。</li>
<li><code>决定分配策略</code><br>
处理机空闲时，根据一定的原则选择一个进程去运行，同时确定获得处理机的时间片的长短。</li>
<li><code>实施处理及的分配和回收</code><br>
进程状态改为等待并插入到相应的等待队列中，还需保留该进程的处理及现场。</li>
</ol>
</li>
<li><strong>调度方式</strong>
<ol>
<li><code>非剥夺方式</code><br>
优先级更高的进程不会抢夺当前正在使用处理机的进程的使用权。</li>
<li><code>可剥夺方式</code><br>
优先级更高的进程直接使正在执行的进程停止，立即把处理机分配给高优先级的进程。</li>
</ol>
</li>
<li><strong>进程优先数调度算法</strong>
<ol>
<li><code>什么是进程优先数调度算法</code><br>
预先确定各进程的优先数，系统将处理及的使用权赋予就绪队列中具备最高优先级的就绪进程。</li>
<li><code>优先级的设计</code>
<ul>
<li>若采用多个优先级，且每一个优先级有多个进程，一般采用多队列机构。</li>
<li>若每一个优先级上只能有一个进程，则以优先级的高低排序，具有最高优先级的进程放在队首并第一个被分派的进程。</li>
</ul>
</li>
<li><code>静态优先数和动态优先数</code>
<ul>
<li>静态优先数：在进程被创建时确定</li>
<li>动态优先数：当耗尽一个时间定额时，优先数被调整。</li>
</ul>
</li>
</ol>
</li>
<li><strong>循环轮转调度</strong><br>
<strong>循环轮转(ROUND-ROBIN)</strong>
<ol>
<li><code>简单循环轮转调度</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E7%AE%80%E5%8D%95%E5%BE%AA%E7%8E%AF%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" alt="简单循环轮转调度"><br>
时间片<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>的计算公式为:<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>q</mi><mo>=</mo><mfrac><mi>t</mi><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">{
    q = \frac{t}{n}
}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.9781em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2921em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>为用户所能接受的响应时间；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>为进入系统的进程数目。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>不能选的太大也不能选的太小。<br>
改善轮转法的调度性能：
<ul>
<li>将固定时间片改为可变时间片，从固定时间片轮转法演变为可变时间片轮转法</li>
<li>将但就绪队列改为多就绪队列，多就绪队列轮转法</li>
</ul>
</li>
</ol>
</li>
<li><strong>多级反馈队列调度</strong><br>
<code>多级反馈队列调度(Multilevel Feedback Queue Scheduling)算法采用多就绪队列结构</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" alt="多级反馈队列调度算法"><br>
进程从等待状态进入就绪队列时，首先进入序列较小的队列中；当某进程分到处理机时，就给它一个与就绪队列对应的时间片；该时间片用完时，它被迫释放处理机，并进入到下一级的就绪队列中。虽然它重新执行的时间被推迟了一些，但在下次得到处理机时，时间片却增加了一倍。</li>
<li><strong>调度用的进程状态变迁图</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81%E5%9B%BE.png" alt="进程状态变迁图">
<ul>
<li>当CPU空闲时，首先从高优先级就绪队列中选取进程去运行，给定时间片为100ms</li>
<li>若此队列为空，则从中优先级就绪队列中选择进程，给定时间片也为100ms</li>
<li>只有在无高、中优先级的进程时才运行低优先级的就绪进程，给定时间片为500ms</li>
</ul>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="七、主存管理"><strong>七、主存管理</strong></h2>
<ol>
<li><strong>主存管理概述</strong>
<ol>
<li><strong>主存分片共享</strong><br>
现代操作系统的主存管理必须实现主存分配、主存保护、虚拟主存等功能
<ul>
<li>将逻辑地址映射为物理主存地址</li>
<li>再多用户之间分配物理主存</li>
<li>对各用户区的信息提供保护措施</li>
<li>扩充逻辑主存区</li>
</ul>
</li>
<li><strong>程序的逻辑组织</strong>
<ol>
<li><code>一维地址结构</code><br>
所有程序和数据经编译、连接后成为一个连续的地址空间。</li>
<li><code>二维地址结构</code><br>
把程序分成若干模块或过程，把可修改的数据和不可修改的数据分开，分成各种各样的段。每个分段是一个连续的地址区。<br>
确定任一个线性地址空间中的指令地址或操作数地址需要两个信息，<strong>一是信息所在的分段</strong>，<strong>二是信息在段内的偏移量</strong>。</li>
</ol>
</li>
</ol>
</li>
<li><strong>主存管理的功能</strong>
<ol>
<li><strong>虚拟存储器</strong>
<ol>
<li><code>提供虚拟存储器的必要性</code><br>
为了方便用户的使用和有效地支持多用户对主存的共享。操作系统将存储概念分为物理主存和逻辑主存两类，用户看到地存储空间为<strong>逻辑地址空间</strong>，信息真正存储在物理主存中为<strong>储存空间</strong></li>
<li><code>虚存的定义</code><br>
将用户的逻辑主存与物理主存分开，这是现代计算机对虚存的实质性描述。换句话说：只装入部分程序代码和数据就启动其运行，由操作系统和硬件相配合完成主存和辅存之间的信息的动态调度。<br>
实现虚拟存储技术需要有如下物质基础：
<ul>
<li>相当容量的辅存</li>
<li>一定容量的主存</li>
<li>地址变换机构</li>
</ul>
</li>
</ol>
</li>
<li><strong>地址映射</strong>
<ol>
<li><code>什么是地址映射</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E8%A3%85%E5%85%A5%E4%B8%BB%E5%AD%98.png" alt="程序的地址空间装入主存"></li>
<li><code>地址映射方式</code>
<ul>
<li>编程或编译时确定地址映射关系<br>
对应关系如果在程序编写时确定，则结果为一个不能浮动的程序模块。程序经过编译后，得到的也是一个不能浮动的程序模块。</li>
<li>静态地址映射<br>
对应关系在将程序装入主存时实现的，编译和链接的结果就是一个可以浮动的程序模块。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="静态重定位的实现"></li>
<li>动态地址映射<br>
如果在程序执行过程中每次访问存储器时，都通过一个地址变换机构将虚地址变换为主存的物理地址，对应关系是在程序执行过程中实现的。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B.png" alt="动态地址映射"></li>
</ul>
</li>
</ol>
</li>
<li><strong>主存分配</strong><br>
主存分配功能包括<strong>指定分配策略</strong>，<strong>构造分配用的数据结构</strong>，<strong>响应主存分配请求</strong>，<strong>决定用户程序的主存位置并将程序装入主存</strong><br>
主存管理存储器的策略有以下三种：
<ul>
<li><strong>放置策略</strong>——如何在一些空闲存储区中选择一个空闲区或若干空闲区的原则</li>
<li><strong>调入策略</strong>——决定信息装入主存的时机，实在需要信息时调入信息（<strong>请调策略</strong>），还是预先调入信息（<strong>预调策略</strong>）。</li>
<li><strong>淘汰策略</strong>——对一个应用程序而言，它在主存中已没有可用的空闲区时，决定哪些信息可以从主存中移走。<br>
主存分配中一般对主存区域的划分有两种：一是将主存划分成大小不等的区域（段式系统），二是将主存等分为一系列大小相等的块（页式系统）。</li>
</ul>
</li>
<li><strong>存储保护</strong><br>
存储保护的目的是防止用户程序之间的互相干扰，一般会采取一些隔离性措施，例如上下界防护与存储键防护。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E7%95%8C%E9%99%90%E5%AF%84%E5%AD%98%E5%99%A8%E4%BF%9D%E6%8A%A4.png" alt="界限寄存器保护"></li>
</ol>
</li>
<li><strong>分区存储管理及存在的问题</strong>
<ol>
<li><strong>动态分区存储管理技术</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D.png" alt="动态分区存储管理方案中的分区分配"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E6%96%B9%E6%B3%95%E4%B8%AD%E5%AD%98%E5%82%A8%E5%8C%BA%E7%9A%84%E9%87%8A%E6%94%BE.png" alt="动态分区方法中存储区的释放"></li>
<li><strong>分区分配机构</strong><br>
描述主存资源的数据结构有<strong>主存资源信息块</strong>和<strong>分区描述器</strong>。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/rib_and_pd.png" alt="rib_and_pd">
<ul>
<li><code>flag</code>——分配标志。空闲分区0，已分配区非0。</li>
<li><code>size</code>——分区大小。分区可用字数n + 3(pd所需字数和)。</li>
<li><code>next</code>——勾链字。下一个空闲分区。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E7%9A%84%E7%A9%BA%E9%97%B2%E5%8C%BA%E9%98%9F%E5%88%97.png" alt="动态分区的空闲区队列"></li>
</ul>
</li>
<li><strong>分区分配与放置策略</strong>
<ol>
<li><code>分区分配</code><br>
主存分配包括<strong>分配</strong>和<strong>回收主存块</strong>两个功能</li>
<li><code>放置策略</code>
<ul>
<li>首次适应算法</li>
<li>最佳适应算法</li>
<li>最坏适应算法<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E6%94%BE%E7%BD%AE%E7%AD%96%E7%95%A5%E7%AE%97%E6%B3%95.png" alt="放置策略算法"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%B8%8D%E5%90%8C%E6%94%BE%E7%BD%AE%E7%AD%96%E7%95%A5%E4%B8%8B%E7%9A%84%E7%A9%BA%E9%97%B2%E5%8C%BA%E9%98%9F%E5%88%97.png" alt="不同放置策略下的空闲区队列"></li>
</ul>
</li>
</ol>
</li>
<li><strong>碎片问题及拼接技术</strong>
<ul>
<li>分区回收时立刻拼接（开销大）</li>
<li>找不到足够大的空闲区，而空闲区总量可以满足程序需要时拼接。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E5%8C%BA%E6%8B%BC%E6%8E%A5.png" alt="分区分配中的存储区拼接"></li>
</ul>
</li>
</ol>
</li>
<li><strong>页式存储管理</strong>
<ol>
<li><strong>页式系统应解决的问题</strong>
<ul>
<li><code>页式系统的地址映射</code><br>
动态地址映射</li>
<li><code>请调策略</code><br>
判断当前访问的信息是否在主存，当确认所访问的页面不在主存时，系统必须从辅存调入请求的页面，这就是页面请调。</li>
<li><code>放置策略</code><br>
也是系统的存储分配可采用固定空间调度算法，对每个程序分配一定数目的主存块，一般程序分配到的主存块数小于程序的页面总数。</li>
<li><code>淘汰策略</code><br>
当需要调入一新页，而该程序所分得的主存块数已全部用完时，需要确定哪个页面可淘汰，从而空出页框以便装入所需要的那一页。</li>
</ul>
</li>
<li><strong>页式地址变换</strong>
<ol>
<li><code>页表</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%88%86%E9%A1%B5%E6%98%A0%E5%83%8F%E5%AD%98%E5%82%A8.png" alt="分页映像存储"></li>
<li><code>虚地质结构</code>
<table>
<thead>
<tr>
<th style="text-align:center">------------- 页号 ------------</th>
<th style="text-align:center">-页内位移-</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">p</td>
<td style="text-align:center">w</td>
</tr>
</tbody>
</table>
</li>
<li><code>页式地址变换</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E9%A1%B5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B.png" alt="页式系统的地址变换过程"></li>
<li><code>联想存储器</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%BF%AB%E8%A1%A8.png" alt="快表"></li>
</ol>
</li>
<li><strong>请调页面的机制</strong>
<ul>
<li>怎样发现所要访问的页面在不在主存</li>
<li>如确认所要访问的页面不在主存时如何处理</li>
</ul>
<ol>
<li><code>扩充页表功能</code><br>
中断位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>表示此页不在主存，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>表示页在主存<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E6%89%A9%E5%85%85%E5%8A%9F%E8%83%BD%E7%9A%84%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="扩充功能的页表结构"></li>
<li><code>缺页判断与处理</code>
<ul>
<li>i=0查块号b，b+w物理地址</li>
<li>i=1要先把这一页调入主存，安置在某一块中再在逻辑地址再定位。<br>
<strong>详见P199</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E6%98%A0%E5%83%8F%E5%AD%98%E5%82%A8.png" alt="请求分页映像存储"></li>
</ul>
</li>
</ol>
</li>
<li><strong>淘汰机制与策略</strong>
<ol>
<li><code>页面淘汰机制</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%AE%8C%E6%95%B4%E7%9A%84%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="完整的页表结构">
<ul>
<li><strong>引用位</strong>：用来指示某页最近被访问过没有  == 0 ？ 没被访问过 ：被访问过</li>
<li><strong>改变位</strong>：表示某页是否被修改过 == 1 ？ 已被修改过 ： 未被修改过<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4%E5%92%8C%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="指令执行步骤和缺页中断处理过程"></li>
</ul>
</li>
<li><code>置换算法</code><br>
当索取一页面并送入主存时，必须将该程序已在主存中的某一页面淘汰掉。用来选择淘汰那一页的规则就叫做置换算法。</li>
<li><code>颠簸(thrashin)</code><br>
索取页面的速度超过了系统所能提供的速度时，系统必须等待辅存的工作。</li>
</ol>
</li>
<li><strong>几种置换算法</strong>
<blockquote>
<p><strong>详见(页式存储)</strong></p>
</blockquote>
</li>
</ol>
</li>
<li><strong>段式和段页式存储管理</strong>
<ol>
<li><strong>段式地址结构</strong><br>
段式系统中程序的地址空间由若干个逻辑分段组成，每个分段有自己的名字，对于一个分段而言，他是一个连续的地址区。</li>
<li><strong>段式地址变换</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%85%B7%E6%9C%89%E6%AE%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" alt="段式地质结构"><br>
程序地址的一般形式由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s, w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>组成，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>是段号，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>是段内位移。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E6%AE%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="段式地址结构"><br>
段式地址变换由**段表(smt)**来实现。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E6%AE%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="段式地址变换">
<ul>
<li>取出程序地址(s, w)</li>
<li>用s检索段表</li>
<li>如w &lt; 0 或 w &gt;= L，则主存越界</li>
<li>(b + w)即为所需主存地址</li>
</ul>
</li>
<li><strong>扩充段表功能</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E6%89%A9%E5%85%85%E5%8A%9F%E8%83%BD%E7%9A%84%E6%AE%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="扩充功能的段表结构">
<ul>
<li>页式系统可实现存储空间的物理划分，段式系统实现的是程序地址空间的逻辑划分</li>
<li>页面的大小固定且相等；段式系统中的分段，长度可变且不相等，由用户编程时决定。</li>
<li>页面是用户不可见的，而分段是用户可见的。</li>
<li>将程序地址分成页号p和页内位移w是硬件的功能，w字段的溢出将自动加入到页号中，程序地址分成段号s和段内位移w是逻辑功能，w字段的溢出将产生主存越界</li>
</ul>
</li>
<li><strong>段页式存储管理</strong><br>
段页式地址属于三维地址（段号+页号+页内偏移）<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" alt="段页式地址空间"><br>
段页式地址变换中要得到物理地址须经过三次主存访问：
<ul>
<li>第一次访问段表，得到页表起始地址；</li>
<li>第二次访问页表，得到主存块号；</li>
<li>第三次将主存块号与页内位移结合，得到物理地址。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86.png" alt="段页式管理"></li>
</ul>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="八、设备管理"><strong>八、设备管理</strong></h2>
<ol>
<li><strong>设备管理概述</strong>
<ol>
<li><strong>设备管理的功能</strong>
<ol>
<li><code>状态跟踪</code></li>
<li><code>设备分配</code></li>
<li><code>设备控制</code></li>
</ol>
</li>
<li><strong>设备独立性</strong>
<ol>
<li><code>概念</code><br>
为用户建立虚环境，在用户程序中应避免使用实际的物理名，而采用逻辑物理名。<strong>设备管理器</strong>的任务之一就是把逻辑设备名转换成物理设备名。
<ul>
<li>一个程序独立于分配给它的某种类型的具体设备</li>
<li>程序应尽可能与它所使用的I/O设备类型无关</li>
</ul>
</li>
<li><code>设备独立性的实现</code>
<ul>
<li>软通道实现设备独立性<br>
指定的逻辑设备名来定义一个设备，提供从程序到特定设备的传输线。</li>
<li>通过指派命令实现设备独立性<br>
一次对一个设备赋名，也可以用此命令将高级语言中使用的逻辑设备名赋给实际设备。</li>
<li>逻辑设备描述器<br>
<code>ldd(logic_device_description)</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E5%92%8C%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E6%8F%8F%E8%BF%B0%E5%99%A8.png" alt="进程的设备信息和逻辑设备描述器"></li>
</ul>
</li>
<li><code>设备独立性的优点</code>
<ul>
<li>方便用户</li>
<li>提高设备的利用率</li>
<li>提高系统的可适应性和可扩展性</li>
</ul>
</li>
</ol>
</li>
<li><strong>设备控制块</strong>
<ol>
<li><code>设备控制块结构</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%9D%97.png" alt="设备控制块"></li>
<li><code>命令转换表</code><br>
命令转换表记录了一台设备能实施I/O操作，表中包含设备特定的I/O例程地址，不具备某一功能时，在其例程地址上填“-1”。</li>
</ol>
</li>
</ol>
</li>
<li><strong>缓冲技术</strong>
<ol>
<li><strong>缓冲概述</strong><br>
中断技术和通道技术可以缓解CPU和I/O设备间速度不匹配的问题。
<ol>
<li><code>什么是缓冲</code><br>
CPU和IO设备速度不匹配，要用缓冲技术。</li>
<li><code>利用缓冲技术进行I/O操作</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%88%A9%E7%94%A8%E7%BC%93%E5%86%B2%E5%8C%BA%E8%BF%9B%E8%A1%8C%E5%86%99%E6%93%8D%E4%BD%9C.png" alt="利用缓冲区进行写操作"></li>
<li><code>缓冲技术解决的问题</code>
<ul>
<li>解决速度差异的问题</li>
<li>协调传输数据大小不一致的问题</li>
<li>应用程序的拷贝语义问题</li>
</ul>
</li>
</ol>
</li>
<li><strong>常用的缓冲技术</strong>
<ol>
<li><code>双缓冲</code>
<ul>
<li>双缓冲用于数据输入/输出<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%8F%8C%E7%BC%93%E5%86%B2.png" alt="双缓冲"></li>
</ul>
</li>
<li><code>缓冲池</code></li>
</ol>
</li>
</ol>
</li>
<li><strong>设备分配</strong>
<ol>
<li><strong>设备分配概述</strong>
<ol>
<li><code>静态分配和动态分配</code></li>
<li><code>I/O设备分配算法</code>
<ul>
<li>FCFS</li>
<li>优先级最高者优先</li>
</ul>
</li>
</ol>
</li>
<li><strong>独享分配</strong><br>
在多用户多进程系统中，为使各应用程序、进程有效地共享系统的外部设备，必须对外部设备进行合理的分配。<br>
有些外部设备的特性适合于一个应用程序独占使用。<br>
<strong>独占设备</strong>是让一个应用程序在整个运行期间独占使用的设备</li>
<li><strong>共享分配</strong><br>
外部设备中如磁盘等直接存取设备都能进行快速的直接存取，它们往往不是让一个应用程序独占而是被多进程共同使用，或者说，这类设备是共享设备。</li>
<li><strong>虚拟分配</strong><br>
在应用程序执行中，由于要等待独占设备传输数据而大大延长了应用程序的处理时间。为了解决这类问题，提出了虚拟分配技术。
<ol>
<li><code>虚拟设备和虚拟分配</code><br>
虚拟设备的思想是利用系统中的便于共享的、快速的存储设备来替代不适合共享的、慢速的字符设备、采用预先收存，延迟发送的方式来改造独占设备。</li>
<li><code>Spool（假脱机系统）</code><br>
现代操作系统大多实现了虚拟设备技术，有的操作系统提供外部设备联机同时操作的功能，称为<strong>Spool(Simultaneous Peripheral Operation On Line)</strong> 系统，又称假脱机系统。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%99%9A%E6%8B%9F%E8%AE%BE%E5%A4%87.png" alt="虚拟设备"></li>
<li><code>虚拟打印功能</code><br>
在多用户系统和网络环境中都提供虚拟打印机，各结点机上的用户都可以使用网络提供的虚拟打印机功能，共享网上的打印机。</li>
</ol>
</li>
</ol>
</li>
<li><strong>输入/输出控制</strong>
<ol>
<li><strong>输入/输出硬件</strong>
<ol>
<li><code>端口(port)</code></li>
<li><code>总线(bus)</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/PC%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="bus"></li>
<li><code>控制器(controller)</code></li>
</ol>
</li>
<li><strong>输入/输出控制方式</strong>
<ol>
<li><code>循环测试I/O方式</code></li>
<li><code>I/O中断方式</code></li>
<li><code>通道方式</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E9%80%9A%E9%81%93%E7%9A%84%E7%B1%BB%E5%9E%8B.png" alt="通道的类型"></li>
<li><code>DMA方式</code><br>
允许DMA控制器“接管”地址线的控制权。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/DMA.png" alt="DMA"></li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="九、文件系统"><strong>九、文件系统</strong></h2>
<ol>
<li><strong>文件系统概述</strong>
<ol>
<li><strong>文件</strong>
<ol>
<li><code>文件的定义及分类</code>
<ul>
<li><strong>文件</strong><br>
文件系统对信息的管理是通过把它所管理的信息（程序和数据）组织成一个个文件的方式来实施的。文件是在逻辑上具有完整意义的信息集合，它有一个名字以供标识，文件名是以字母开头的字母数字串。文件是由文件系统存储和加工的逻辑部件。<br>
- 文件是具有符号名的信息（数据）项的集合<br>
- 文件是具有符号名的记录的集合</li>
<li><strong>文件的分类</strong><br>
按性质和用途分3类：
<ul>
<li>系统文件</li>
<li>程序库文件</li>
<li>用户文件<br>
文件按保护级可分如下几类：</li>
<li>执行文件</li>
<li>只读文件</li>
<li>读写文件</li>
</ul>
</li>
</ul>
</li>
<li><strong>文件名及文件属性</strong>
<ul>
<li>文件名</li>
<li>文件扩展</li>
<li>文件属性</li>
</ul>
</li>
</ol>
</li>
<li><strong>文件系统</strong><br>
文件系统的功能是负责文件的存储并对存入的文件进行保护、检索，负责对文件存储器存储空间的组织和分配等。</li>
<li><strong>文件的组织</strong>
<ol>
<li><code>文件组织的两种结构</code>
<ul>
<li><strong>逻辑文件</strong><br>
逻辑文件是从用户角度看到的文件面貌，即用户对信息进行逻辑组织形成的文件结构。</li>
<li><strong>物理文件</strong><br>
物理文件是信息在物理存储器上的存储方式，是数据的物理表示和组织。</li>
</ul>
</li>
<li><code>逻辑记录和块</code>
<ul>
<li><strong>逻辑记录</strong><br>
文件中按信息在逻辑上的独立含义来划分的信息单位</li>
<li><strong>物理记录</strong><br>
在存储介质上，由连续信息所组成的一个区域称为块，也叫物理记录</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>文件的逻辑结构和存取方法</strong>
<ol>
<li><strong>文件的逻辑结构</strong>
<ul>
<li><code>流式文件</code><br>
无结构的流式文件是相关的有序字符的集合</li>
<li><code>记录式文件</code><br>
记录式文件是一种有结构的文件</li>
</ul>
</li>
</ol>
</li>
<li><strong>文件的物理结构</strong>
<ol>
<li><strong>连续文件</strong>
<ol>
<li><code>什么是连续文件？</code><br>
连续文件结构是由一组分配在磁盘连续区域的物理块组成。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E8%BF%9E%E7%BB%AD%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="连续文件结构"></li>
<li><code>连续文件中存取记录的操作</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%AD%98%E5%8F%96%E8%AE%B0%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C.png" alt="存取记录的操作"></li>
<li><code>连续文件的特点</code>
<ul>
<li>连续存取时速度较快</li>
<li>文件长度一经固定便不易改变</li>
<li>文件的增生和扩充不易</li>
</ul>
</li>
</ol>
</li>
<li><strong>串联文件</strong>
<ol>
<li><code>串联文件结构</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%B8%B2%E8%81%94%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="串联文件"></li>
<li><code>文件映照结构</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E6%96%87%E4%BB%B6%E6%98%A0%E7%85%A7%E7%BB%93%E6%9E%84.png" alt="文件映照结构"></li>
</ol>
</li>
<li><strong>索引文件</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="索引文件结构">
<ul>
<li>直接索引<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E7%9B%B4%E6%8E%A5%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="直接索引文件结构"></li>
<li>一级间接索引<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%B8%80%E7%BA%A7%E9%97%B4%E6%8E%A5%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="一级间接索引文件结构"></li>
<li>二级间接索引<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%BA%8C%E7%BA%A7%E9%97%B4%E6%8E%A5%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="二级间接索引文件结构"></li>
</ul>
</li>
<li><strong>文件物理结构比较</strong>
<ul>
<li><code>连续文件特点</code>
<ul>
<li><strong>优点</strong>：不需要额外空间开销，一次可以读出整个文件。</li>
<li><strong>缺点</strong>：不便于动态增长；一次可能要求比较大的连续的存储空间；要求用户提出文件较精确的长度</li>
</ul>
</li>
<li><code>串联文件特点</code>
<ul>
<li><strong>优点</strong>：易于文件的扩充，顺序存取较为方便</li>
<li><strong>缺点</strong>：处理文件时若要所及访问，需要较大的开销，时间上比较浪费。</li>
</ul>
</li>
<li><code>索引文件特点</code>
<ul>
<li><strong>优点</strong>：综合上述两种方法的优点</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><strong>文件存储空间的管理</strong>
<ol>
<li><strong>空闲文件目录</strong></li>
<li><strong>空闲块链</strong></li>
<li><strong>位示图</strong><br>
建立一张位示图，以反映整个存储空间的分配情况。<br>
图中1表示对应的块已分配，0表示对应的块为空白（未分配）。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E4%BD%8D%E7%A4%BA%E5%9B%BE.png" alt="位示图"></li>
</ol>
</li>
<li><strong>文件目录</strong>
<ol>
<li><strong>文件目录及其内容</strong>
<ol>
<li><code>什么是文件目录</code><br>
文件目录是记录系统中所有文件的名字及其存放地址的目录表，表中还包括关于文件的说明信息和控制信息。</li>
<li><code>文件目录的内容</code>
<ul>
<li>文件名</li>
<li>文件的逻辑结构</li>
<li>文件的物理结构</li>
<li>存取控制信息</li>
<li>管理信息</li>
<li>文件类型</li>
</ul>
</li>
</ol>
</li>
<li><strong>一级文件目录及缺点</strong><br>
特点是简单，缺点是容易出现重名的问题。</li>
<li><strong>多级文件目录</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="多级目录结构"></li>
</ol>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://kuur1su.github.io">Kurisu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kuur1su.github.io/2025/05/15/OperationSystem-2025-05-15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/">https://kuur1su.github.io/2025/05/15/OperationSystem-2025-05-15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://kuur1su.github.io" target="_blank">Steins;Gate</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post-share"><div class="social-share" data-image="/image/theme01.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/image/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/image/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/26/AlgorithmAndDataStructure-2025-04-26-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A3%80%E7%B4%A2%E6%A0%91/" title="最优二叉检索树"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">最优二叉检索树</div></div><div class="info-2"><div class="info-item-1"> 最优二叉检索树  一、介绍  最优二分检索树的意思是，给你k1,k2,k3...knk_1, k_2, k_3...k_nk1​,k2​,k3​...kn​n个关键字，把这些关键字整理成一个二叉检索树，给你每个结点的命中概率pip_ipi​和丢失概率qiq_iqi​，未命中看成每个节点区间的虚拟关键字d0,d1,d2...dnd_0,d_1,d_2...d_nd0​,d1​,d2​...dn​ 其中ki&lt;di&lt;ki+1k_i &lt; d_i &lt; k_{i+1}ki​&lt;di​&lt;ki+1​，d0&lt;k0d_0 &lt; k_0d0​&lt;k0​，kn&lt;dnk_n &lt; d_nkn​&lt;dn​。每个点都有自己的枚举代价，也就是二叉树的深度，那么我们可以知道：  E[T]  =  ∑i=1npi(depthT(ki)+1)  +  ∑i=0nqi(depthT(di)+1){    E[T] \;=\; \sum_{i=1}^n p_i\bigl(\mathrm{depth}_T(k_i)+1\bigr)         ...</div></div></div></a><a class="pagination-related" href="/2025/05/18/Cryptography-2025-05-18-%E5%AF%86%E7%A0%81%E5%AD%A6/" title="密码学"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/screenshot01.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">密码学</div></div><div class="info-2"><div class="info-item-1">一、密码学概述 密码学的基本知识 基本信息  密码学的基本目的是使得两个在不安全信道中通信的人，Alice和Bob以一种使他们的敌手Eve不能明白和理解通信内容的方式进行通信。 Alice发送给Bob的信息，称为明文(plaintext)。Alice使用预先商量好的密钥(key)对明文进行加密，加密过的明文称为密文(ciphertext)。 加密通信基本过程，加密算法EEE，解密算法DDD，明文MMM，密文CCC，要传输明文MMM   C=E(M)C = E(M)C=E(M)     D(C)=MD(C) = MD(C)=M     D(E(M))=MD(E(M)) = MD(E(M))=M    密码学的基本概念  明文消息(Plaintext)：未加密的原消息 密文消息(Ciphertext)：加密后的消息 密钥(Key)：加解密过程中只有发送者和接收者知道的关键信息，分为加密密钥(Encryption Key)和解密密钥(Decryption...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/11/OperationSystem-2025-04-11-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="Linux操作系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/screenshot03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-11</div><div class="info-item-2">Linux操作系统</div></div><div class="info-2"><div class="info-item-1"> Linux  一、基本指令   pwd hcy@hcy-virtual-machine:~$ pwd 这行代码的含义是查询当前文件夹下的路径 eg： 输出：/home/hcy   cd hcy@hcy-virtual-machine:~$ cd  cd ..  意思是回退到上一个文件夹目录 cd xxx 意思是转移到该盘符    vim  注意！使用vim前需要下载！  hcy@hcy-virtual-machine:~$ vim xxx.xxx 这段代码的含义是利用vim生成一个空的文件，文件名和后缀可以自己控制   mkdir hcy@hcy-virtual-machine:~$ mkdir xxx 这段代码的含义是在当前目录下生成一个文件夹   rmdir hcy@hcy-virtual-machine:~$ rmdir xxx 删除当前目录下的文件夹   rm hcy@hcy-virtual-machine:~$ rm xxx.xxx 删除某个文件   mv hcy@hcy-virtual-machine:~$ mv oldfile...</div></div></div></a><a class="pagination-related" href="/2025/04/17/OperationSystem-2025-04-17-%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8/" title="页式存储"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/screenshot02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-17</div><div class="info-item-2">页式存储</div></div><div class="info-2"><div class="info-item-1"> 页式存储   我们知道操作系统页式存储有三种调度方式，下面讲研究一下这三种调度算法  一、FIFO(First in First out)   介绍 先进先出的进程调度算法，看起来是最合理最公平的，但是其实并不是最高效的。如果有进程需要被频繁调用，那么一直进一直出的开销是很大的，不过我们可以写代码来实现一下这个算法   算法实现 12345678910111213141516171819double fifo(const std::vector&lt;int&gt;&amp; page_stream, int frames) &#123;    std::unordered_set&lt;int&gt; memory;    std::queue&lt;int&gt; fifo_queue;    int page_faults = 0;       for (int page : page_stream) &#123;        if (memory.find(page) == memory.end()) &#123;            page_faults++;...</div></div></div></a><a class="pagination-related" href="/2025/04/15/AlgorithmAndDataStructure-2025-04-15-%E5%9B%BE/" title="图"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">图</div></div><div class="info-2"><div class="info-item-1"> 图  一、介绍  图的组成和分类 图的形式可以说是非常直观，由顶点和边构成，图分为无向图(Undirected Graph)，有向图(Directed Graph)，加权图(Weighted Graph)。 图的关键术语  度 : 一个顶点连接的边数（无向图中）。 入度/出度 : 有向图中指向某顶点的边数（入度）或从该顶点出发的边数（出度）。 路径 : 从一个顶点到另一个顶点的边序列。 环 : 起点和终点相同的路径。 连通图 : 任意两个顶点间都存在路径（无向图）。 强连通图 : 有向图中任意两顶点间存在双向路径。   图的表示方法   邻接矩阵（Adjacency Matrix） 用二维数组存储顶点间的连接关系。矩阵元素 matrix[i][j] 表示顶点 i 到 j 是否存在边（或边的权重）。 优点：快速判断两顶点是否相连；缺点：空间复杂度高（O(V²)），适合稠密图。   邻接表（Adjacency...</div></div></div></a><a class="pagination-related" href="/2025/04/10/AlgorithmAndDataStructure-2025-04-10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-10</div><div class="info-item-2">动态规划</div></div><div class="info-2"><div class="info-item-1"> 动态规划   动态规划是一个很大的板块，分为很多的方面给，这篇文章只是给出一个最基本的概念，后续动态规划的各种类型会逐渐更新。  一、介绍 动态规划其实就是一种把大问题分解成小的并且有关联的子问题，子问题之间有重叠的部分，可以通过子问题的答案推断出后续问题的答案。 动态规划还可以是当成一种缓存表，把递归调用得到的结果用一张dpdpdp表存起来，以后遇到相似的情况直接从缓存中找答案，用空间换时间。 然后是严格位置依赖的动态规划，这种方式需要找到状态定义和状态转移方程，而往往找出最优的状态定义和转移方程是困难的，需要花大量的时间积累经验以及依赖一点灵感。 二、分类 动态规划可以分为一维动态规划，二维动态规划，01背包，完全背包，分组背包，多重背包和混合背包，区间dp，状压dp等等 </div></div></div></a><a class="pagination-related" href="/2025/04/15/AlgorithmAndDataStructure-2025-04-15-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E5%88%86%E6%B2%BB/" title="归并排序和归并分治"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/budalagong.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">归并排序和归并分治</div></div><div class="info-2"><div class="info-item-1">  归并排序和归并分治  一、归并排序  介绍 不得不说，归并排序是一种非常稳定的排序方式，时间复杂度可以达到O(nlogn)O(nlogn)O(nlogn)级别，同样也是最坏情况下的最好的排序方式，主要思想就是把一个大问题分成两个子问题，把子问题搞定后再来合并 代码实现123456789101112131415161718192021222324252627282930313233vector&lt;int&gt; temp;void mergeSort(vector&lt;int&gt;&amp; a, int l, int r) &#123;    if (l &gt;= r) return;    int m = (l + r) / 2;    mergeSort(a, l, m);    mergeSort(a, m + 1, r);    int i = l, j = m + 1, k = l;    while (i &lt;= m &amp;&amp; j &lt;= r) &#123;        temp[k++] = (a[i] &lt;= a[j])...</div></div></div></a><a class="pagination-related" href="/2025/04/25/AlgorithmAndDataStructure-2025-04-25-%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/screenshot04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-25</div><div class="info-item-2">并查集</div></div><div class="info-2"><div class="info-item-1"> 并查集  一、介绍 并查集是一种很优雅的技巧，能够让时间复杂度维持在常数级别，大概是O(α(n))O(α(n))O(α(n))(ααα 是反阿克曼函数) 把有相同性质的元素合并在一个元素中。 二、代码实现 1234567891011121314151617181920212223242526272829class DSU &#123;private:    vector&lt;int&gt; parent;public:    //初始化    DSU(int n) : parent(n + 1) &#123;        for (int i = 0; i &lt;= n; i++) &#123;            parent[i] = i;        &#125;    &#125;    //带路径查找并压缩    int find(int x) &#123;        if (parent[x] != x) &#123;            parent[x] = find(parent[x]);        &#125;       ...</div></div></div></a><a class="pagination-related" href="/2025/04/25/AlgorithmAndDataStructure-2025-04-25-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" title="最小生成树"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/train.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-25</div><div class="info-item-2">最小生成树</div></div><div class="info-2"><div class="info-item-1"> 最小生成树  一、Kurskal算法  介绍 kurskal算法的核心在于把边按照权重从小到大排序，从小边开始遍历，把每条边都加入集合，如果生成环就把边踢出集合，知道把所有边都遍历一遍就可以得到最小生成树 代码  利用并查集实现kurskal   12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class DSU &#123;private:    vector&lt;int&gt; parent;    int sets;public:    DSU(int n) : parent(n + 1) &#123;        for (int i = 1; i &lt;= n; i++) &#123;            parent[i] = i;            //sets++;        &#125;    &#125;     int find(int x) &#123;        return...</div></div></div></a><a class="pagination-related" href="/2025/04/26/AlgorithmAndDataStructure-2025-04-26-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A3%80%E7%B4%A2%E6%A0%91/" title="最优二叉检索树"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-26</div><div class="info-item-2">最优二叉检索树</div></div><div class="info-2"><div class="info-item-1"> 最优二叉检索树  一、介绍  最优二分检索树的意思是，给你k1,k2,k3...knk_1, k_2, k_3...k_nk1​,k2​,k3​...kn​n个关键字，把这些关键字整理成一个二叉检索树，给你每个结点的命中概率pip_ipi​和丢失概率qiq_iqi​，未命中看成每个节点区间的虚拟关键字d0,d1,d2...dnd_0,d_1,d_2...d_nd0​,d1​,d2​...dn​ 其中ki&lt;di&lt;ki+1k_i &lt; d_i &lt; k_{i+1}ki​&lt;di​&lt;ki+1​，d0&lt;k0d_0 &lt; k_0d0​&lt;k0​，kn&lt;dnk_n &lt; d_nkn​&lt;dn​。每个点都有自己的枚举代价，也就是二叉树的深度，那么我们可以知道：  E[T]  =  ∑i=1npi(depthT(ki)+1)  +  ∑i=0nqi(depthT(di)+1){    E[T] \;=\; \sum_{i=1}^n p_i\bigl(\mathrm{depth}_T(k_i)+1\bigr)         ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/kurisu3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Kurisu</div><div class="author-info-description">学而不思则罔，思而不学则殆</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Kuur1su"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Kuur1su" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3325771476@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎参观！会随缘更新自己的学习生活quq。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text"> 操作系统OS </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">一、绪论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="toc-number">1.2.</span> <span class="toc-text">二、操作系统的结构和硬件支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.</span> <span class="toc-text">三、操作系统用户接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">四、进程及进程管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E8%B0%83%E5%BA%A6"><span class="toc-number">1.5.</span> <span class="toc-text">五、资源分配与调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">1.6.</span> <span class="toc-text">六、处理机调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">七、主存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">1.8.</span> <span class="toc-text">八、设备管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.9.</span> <span class="toc-text">九、文件系统</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/11/AlgorithmAndDataStructure-2025-08-11-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/" title="最长递增子序列问题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="最长递增子序列问题"/></a><div class="content"><a class="title" href="/2025/08/11/AlgorithmAndDataStructure-2025-08-11-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/" title="最长递增子序列问题">最长递增子序列问题</a><time datetime="2025-08-11T10:42:13.000Z" title="发表于 2025-08-11 18:42:13">2025-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/11/AlgorithmContest-2025-08-11-NKRound104/" title="NKRound104"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NKRound104"/></a><div class="content"><a class="title" href="/2025/08/11/AlgorithmContest-2025-08-11-NKRound104/" title="NKRound104">NKRound104</a><time datetime="2025-08-11T06:08:32.000Z" title="发表于 2025-08-11 14:08:32">2025-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/11/AlgorithmContest-2025-08-11-CF1042/" title="CF1042"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/screenshot03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CF1042"/></a><div class="content"><a class="title" href="/2025/08/11/AlgorithmContest-2025-08-11-CF1042/" title="CF1042">CF1042</a><time datetime="2025-08-11T06:07:38.000Z" title="发表于 2025-08-11 14:07:38">2025-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/11/AlgorithmContest-2025-08-11-ABC418/" title="ABC418"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ABC418"/></a><div class="content"><a class="title" href="/2025/08/11/AlgorithmContest-2025-08-11-ABC418/" title="ABC418">ABC418</a><time datetime="2025-08-11T06:07:09.000Z" title="发表于 2025-08-11 14:07:09">2025-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/08/AlgorithmAndDataStructure-2025-08-08-%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二叉树"/></a><div class="content"><a class="title" href="/2025/08/08/AlgorithmAndDataStructure-2025-08-08-%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">二叉树</a><time datetime="2025-08-08T11:53:22.000Z" title="发表于 2025-08-08 19:53:22">2025-08-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By Kurisu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  });
</script>
<canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/light.js"></script><script defer src="/js/runtimes.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><!-- hexo injector body_end end --></body></html>