<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>贪心算法 | Steins;Gate</title><meta name="author" content="Kurisu"><meta name="copyright" content="Kurisu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="贪心  贪心是一种出现非常频繁的思路，常见于各种比赛题中，非常符合自然智慧，和排序，堆结构等密切相关  一些经典例题 LeetCode-179. 最大数 12345678910111213141516171819202122232425class Solution &#123;public:    string largestNumber(vector&lt;int&gt;&amp; nums)">
<meta property="og:type" content="article">
<meta property="og:title" content="贪心算法">
<meta property="og:url" content="https://kuur1su.github.io/2025/08/13/AlgorithmAndDataStructure-2025-08-13-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Steins;Gate">
<meta property="og:description" content="贪心  贪心是一种出现非常频繁的思路，常见于各种比赛题中，非常符合自然智慧，和排序，堆结构等密切相关  一些经典例题 LeetCode-179. 最大数 12345678910111213141516171819202122232425class Solution &#123;public:    string largestNumber(vector&lt;int&gt;&amp; nums)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kuur1su.github.io/image/Roxy1.png">
<meta property="article:published_time" content="2025-08-13T00:12:24.000Z">
<meta property="article:modified_time" content="2025-08-14T15:22:12.600Z">
<meta property="article:author" content="Kurisu">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="贪心">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kuur1su.github.io/image/Roxy1.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "贪心算法",
  "url": "https://kuur1su.github.io/2025/08/13/AlgorithmAndDataStructure-2025-08-13-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/",
  "image": "https://kuur1su.github.io/image/Roxy1.png",
  "datePublished": "2025-08-13T00:12:24.000Z",
  "dateModified": "2025-08-14T15:22:12.600Z",
  "author": [
    {
      "@type": "Person",
      "name": "Kurisu",
      "url": "https://kuur1su.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/image/Steins.ico"><link rel="canonical" href="https://kuur1su.github.io/2025/08/13/AlgorithmAndDataStructure-2025-08-13-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '贪心算法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background:url(https://Kuur1su.github.io/image/school_theme.jpg)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/kurisu3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/Roxy1.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Steins;Gate</span></a><a class="nav-page-title" href="/"><span class="site-name">贪心算法</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">贪心算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-13T00:12:24.000Z" title="发表于 2025-08-13 08:12:24">2025-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-14T15:22:12.600Z" title="更新于 2025-08-14 23:22:12">2025-08-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/">贪心</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>6分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-08-14 23:22:12&quot;}" hidden></div><h2 id="贪心">贪心</h2>
<blockquote>
<p>贪心是一种出现非常频繁的思路，常见于各种比赛题中，非常符合自然智慧，和排序，堆结构等密切相关</p>
</blockquote>
<h2 id="一些经典例题">一些经典例题</h2>
<h3 id="LeetCode-179-最大数">LeetCode-<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-number/">179. 最大数</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">std::vector&lt;std::string&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tmp[i] = std::<span class="built_in">to_string</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(),</span><br><span class="line">                  [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) &#123; <span class="keyword">return</span> a + b &gt; b + a; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans += tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-1029-两地调度">LeetCode-<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-city-scheduling/">1029. 两地调度</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">twoCitySchedCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = costs.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// 我们假设让所有人先都去A，然后看看谁去B的代价最小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            a[i] = costs[i][<span class="number">1</span>] - costs[i][<span class="number">0</span>];</span><br><span class="line">            sum += costs[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> m = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-1553-吃掉-N-个橘子的最少天数">LeetCode-<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/">1553. 吃掉 N 个橘子的最少天数</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp.<span class="built_in">count</span>(n) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = std::<span class="built_in">min</span>(<span class="number">1</span> + n % <span class="number">2</span> + <span class="built_in">minDays</span>(n / <span class="number">2</span>), <span class="number">1</span> + n % <span class="number">3</span> + <span class="built_in">minDays</span>(n / <span class="number">3</span>));</span><br><span class="line">        dp[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-630-课程表-III">LeetCode-<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-iii/">630. 课程表 III</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scheduleCourse</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; courses)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = courses.<span class="built_in">size</span>();</span><br><span class="line">        std::<span class="built_in">sort</span>(courses.<span class="built_in">begin</span>(), courses.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) &#123; </span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        std::priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">        <span class="type">int</span> time = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : courses) &#123;</span><br><span class="line">            <span class="keyword">if</span> (time + c[<span class="number">0</span>] &lt;= c[<span class="number">1</span>]) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(c[<span class="number">0</span>]);</span><br><span class="line">                time += c[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>() &gt; c[<span class="number">0</span>]) &#123;</span><br><span class="line">                    time += c[<span class="number">0</span>] - pq.<span class="built_in">top</span>();</span><br><span class="line">                    pq.<span class="built_in">pop</span>();</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(c[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-LCR-132-砍竹子-II">LeetCode-<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/">LCR 132. 砍竹子 II</a></h3>
<h4 id="思路：">思路：</h4>
<p>贪心思想，观察枚举找规律发现拆成3和2的乘积是最大的，因为最接近<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1E9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 快速幂</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(i64 a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        i64 ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                ans = (ans * a) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            a = (a * a) % mod;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingBamboo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tail = n % <span class="number">3</span> == <span class="number">0</span> ? <span class="number">1</span> : (n % <span class="number">3</span> == <span class="number">1</span> ? <span class="number">4</span> : <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> times = (tail == <span class="number">1</span> ? n : (n - tail)) / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(<span class="number">1LL</span> * <span class="built_in">power</span>(<span class="number">3</span>, times) * tail % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-435-无重叠区间">LeetCode-<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h3>
<h4 id="思路：-2">思路：</h4>
<p>把所有线段按照末尾从小到大排序，然后看看每次</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, cur = <span class="number">-50001</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                cur = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n - ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-1353-最多可以参加的会议数目">LeetCode-<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/">1353. 最多可以参加的会议数目</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxEvents</span><span class="params">(std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; events)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = events.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">sort</span>(events.<span class="built_in">begin</span>(), events.<span class="built_in">end</span>(), </span><br><span class="line">            [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minn = events[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            maxn = std::<span class="built_in">max</span>(maxn, events[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;&gt;&gt; hp;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, cur = <span class="number">-1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d = minn; d &lt;= maxn; d++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; events[i][<span class="number">0</span>] == d) &#123;</span><br><span class="line">                hp.<span class="built_in">emplace</span>(events[i++][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!hp.<span class="built_in">empty</span>() &amp;&amp; hp.<span class="built_in">top</span>() &lt; d) &#123;</span><br><span class="line">                hp.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!hp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                hp.<span class="built_in">pop</span>();</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-502-IPO">LeetCode-<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ipo/">502. IPO</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> w, vector&lt;<span class="type">int</span>&gt;&amp; profits, vector&lt;<span class="type">int</span>&gt;&amp; capital)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = profits.<span class="built_in">size</span>();</span><br><span class="line">        std::vector&lt;std::array&lt;<span class="type">int</span>, 2&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr.<span class="built_in">push_back</span>(&#123;capital[i], profits[i]&#125;);</span><br><span class="line">        std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        std::priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">        <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (curr &lt; n &amp;&amp; arr[curr][<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(arr[curr][<span class="number">1</span>]);</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                w += pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-632-最小区间">LeetCode-<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/">632. 最小区间</a></h3>
<h4 id="思路：-3">思路：</h4>
<p>用一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">set</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal">t</span></span></span></span>来维护区间的最小值和最大值，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(klogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的复杂度，常数时间不太好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf = <span class="number">1E9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestRange</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        std::set&lt;std::array&lt;<span class="type">int</span>, 3&gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            st.<span class="built_in">insert</span>(&#123;nums[i][<span class="number">0</span>], i, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> r = inf;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        std::array&lt;<span class="type">int</span>, 3&gt; maxn, minn;</span><br><span class="line">        <span class="keyword">while</span> (st.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            maxn = *st.<span class="built_in">rbegin</span>();</span><br><span class="line">            minn = *st.<span class="built_in">begin</span>();</span><br><span class="line">            st.<span class="built_in">erase</span>(st.<span class="built_in">begin</span>());</span><br><span class="line">            <span class="keyword">if</span> (maxn[<span class="number">0</span>] - minn[<span class="number">0</span>] &lt; r) &#123;</span><br><span class="line">                r = maxn[<span class="number">0</span>] - minn[<span class="number">0</span>];</span><br><span class="line">                a = minn[<span class="number">0</span>];</span><br><span class="line">                b = maxn[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minn[<span class="number">2</span>] + <span class="number">1</span> &lt; nums[minn[<span class="number">1</span>]].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                st.<span class="built_in">insert</span>(&#123;nums[minn[<span class="number">1</span>]][minn[<span class="number">2</span>] + <span class="number">1</span>], minn[<span class="number">1</span>], minn[<span class="number">2</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://kuur1su.github.io">Kurisu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kuur1su.github.io/2025/08/13/AlgorithmAndDataStructure-2025-08-13-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">https://kuur1su.github.io/2025/08/13/AlgorithmAndDataStructure-2025-08-13-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://kuur1su.github.io" target="_blank">Steins;Gate</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a></div><div class="post-share"><div class="social-share" data-image="/image/Roxy1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/image/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/image/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/11/AlgorithmAndDataStructure-2025-08-11-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/" title="最长递增子序列问题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/screenshot06.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">最长递增子序列问题</div></div><div class="info-2"><div class="info-item-1">最长递增子序列问题  时间复杂度O(nlogn)的解法，与一般dp的解法有所不同，利用了二分搜索的技巧  LeetCode-300. 最长递增子序列 思路： 我们维护一个endsendsends数组，数组中的第iii个元素代表了目前所有长度为i+1i + 1i+1的递增子序列的最小结尾。 这么定义这个ends数组的意义在于，遍历每一个numsnumsnums中的元素，每个元素都会先检查一下再endsendsends中是否有值严格大于curcurcur元素，如果存在就刷新这个最近的大于的元素，更新后的值是更优秀的解，目的是未来可能有多的递增元素的可能。 1234567891011121314151617class Solution &#123;public:    int lengthOfLIS(std::vector&lt;int&gt;&amp; nums) &#123;        std::vector&lt;int&gt; ends;        for (int x : nums) &#123; // lower_bound就是二分            auto...</div></div></div></a><a class="pagination-related" href="/2025/08/17/AlgorithmAndDataStructure-2025-08-17-%E8%B4%A8%E6%95%B0%E7%AD%9B/" title="质数筛"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">质数筛</div></div><div class="info-2"><div class="info-item-1">euler筛 1234567891011121314151617181920int euler(int n) &#123;    std::vector&lt;bool&gt; vis(n + 1);    std::vector&lt;int&gt; prime(n / 2 + 1);    int cnt = 0;    for (int i = 2; i &lt;= n; i++) &#123;        if (!vis[i]) &#123;            prime[cnt++] = i;        &#125;        for (int j = 0; j &lt; cnt; j++) &#123;            if (i * prime[j] &gt; n) &#123;                break;            &#125;            vis[i * prime[j]] = true;            if (i % prime[j] == 0) &#123;               ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/11/AlgorithmContest-2025-08-11-CF1042/" title="CF1042"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/train.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-11</div><div class="info-item-2">CF1042</div></div><div class="info-2"><div class="info-item-1">CF1042 (Div.3)  AC 5 / 8  C. Make it Equal Given two multisets SSS and TTT of size nnn and a positive integer kkk, you may perform the following operations any number (including zero) of times on SSS:  Select an element xxx in SSS, and remove one occurrence of xxx in SSS. Then, either insert x+kx+kx+k into SSS, or insert ∣x−k∣|x-k|∣x−k∣ into SSS.  Determine if it is possible to make SSS equal to TTT. Two multisets SSS and TTT are equal if every element appears the same number of times in SSS...</div></div></div></a><a class="pagination-related" href="/2025/08/18/AlgorithmContest-2025-08-18-NKRound105/" title="NKRound105"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/screenshot01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-18</div><div class="info-item-2">NKRound105</div></div><div class="info-2"><div class="info-item-1">NK Round 105  AC 5/6  C.小苯的01矩阵构造 思路： 观察容易发现，只可能kkk是偶数，奇数不可能出现 123456789101112131415161718192021222324int main() &#123;    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    if (k % 2 == 1) &#123;        std::cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;    &#125; else &#123;        for (int i = 0; i &lt; n; i++) &#123;            for (int j = 0; j &lt; n; j++) &#123;                if (i == j &amp;&amp; i &lt; k / 2) &#123;            ...</div></div></div></a><a class="pagination-related" href="/2025/08/11/AlgorithmContest-2025-08-11-NKRound104/" title="NKRound104"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/screenshot05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-11</div><div class="info-item-2">NKRound104</div></div><div class="info-2"><div class="info-item-1">NK Round 104  AC 5/6  C.小红的不动点分配 \hspace{15pt}小红拿到了 2×n2\times n2×n 个元素，现在她想将这些元素划分为两组（每组恰好 nnn 个元素），且两组内部的顺序均可任意重排。 \hspace{15pt}她想知道，这两个数组的不动点数量之和最多是多少，请你帮帮她。 【名词解释】 \hspace{15pt}不动点：定义整数 i(1≦i≦m)i\left(1\leqq i \leqq m \right)i(1≦i≦m) 是长度为 mmm 的数组 {a1,a2,…,am}\{a_1,a_2,\dots,a_m\}{a1​,a2​,…,am​} 的一个不动点，当且仅当满足 ai=ia_i = iai​=i。 12345678910111213141516171819202122232425262728constexpr int M = 2e5; int main() &#123;    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);         int...</div></div></div></a><a class="pagination-related" href="/2025/08/11/AlgorithmContest-2025-08-11-ABC418/" title="ABC418"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/Roxy1.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-11</div><div class="info-item-2">ABC418</div></div><div class="info-2"><div class="info-item-1">ABC418  AC 4/7  C - Flush On the poker table, there are tea bags of NNN different flavors. The flavors are numbered from 111 through NNN, and there are AiA_iAi​ tea bags of flavor iii (1≤i≤N1 \leq i \leq N1≤i≤N). You will play a game using these tea bags. The game has a parameter called difficulty between 111 and A1+⋯+ANA_1 + \dots + A_NA1​+⋯+AN​, inclusive. A game of difficulty bbb proceeds as follows:  You declare an integer xxx. Here, it must satisfy b≤x≤A1+⋯+ANb \leq x \leq A_1 + \dots +...</div></div></div></a><a class="pagination-related" href="/2025/04/15/AlgorithmAndDataStructure-2025-04-15-%E5%9B%BE/" title="图"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/theme01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">图</div></div><div class="info-2"><div class="info-item-1"> 图  一、介绍  图的组成和分类 图的形式可以说是非常直观，由顶点和边构成，图分为无向图(Undirected Graph)，有向图(Directed Graph)，加权图(Weighted Graph)。 图的关键术语  度 : 一个顶点连接的边数（无向图中）。 入度/出度 : 有向图中指向某顶点的边数（入度）或从该顶点出发的边数（出度）。 路径 : 从一个顶点到另一个顶点的边序列。 环 : 起点和终点相同的路径。 连通图 : 任意两个顶点间都存在路径（无向图）。 强连通图 : 有向图中任意两顶点间存在双向路径。   图的表示方法   邻接矩阵（Adjacency Matrix） 用二维数组存储顶点间的连接关系。矩阵元素 matrix[i][j] 表示顶点 i 到 j 是否存在边（或边的权重）。 优点：快速判断两顶点是否相连；缺点：空间复杂度高（O(V²)），适合稠密图。   邻接表（Adjacency...</div></div></div></a><a class="pagination-related" href="/2025/04/10/AlgorithmAndDataStructure-2025-04-10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/theme01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-10</div><div class="info-item-2">动态规划</div></div><div class="info-2"><div class="info-item-1"> 动态规划   动态规划是一个很大的板块，分为很多的方面给，这篇文章只是给出一个最基本的概念，后续动态规划的各种类型会逐渐更新。  一、介绍 动态规划其实就是一种把大问题分解成小的并且有关联的子问题，子问题之间有重叠的部分，可以通过子问题的答案推断出后续问题的答案。 动态规划还可以是当成一种缓存表，把递归调用得到的结果用一张dpdpdp表存起来，以后遇到相似的情况直接从缓存中找答案，用空间换时间。 然后是严格位置依赖的动态规划，这种方式需要找到状态定义和状态转移方程，而往往找出最优的状态定义和转移方程是困难的，需要花大量的时间积累经验以及依赖一点灵感。 二、分类 动态规划可以分为一维动态规划，二维动态规划，01背包，完全背包，分组背包，多重背包和混合背包，区间dp，状压dp等等 </div></div></div></a><a class="pagination-related" href="/2025/04/25/AlgorithmAndDataStructure-2025-04-25-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" title="最小生成树"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-25</div><div class="info-item-2">最小生成树</div></div><div class="info-2"><div class="info-item-1"> 最小生成树  一、Kurskal算法  介绍 kurskal算法的核心在于把边按照权重从小到大排序，从小边开始遍历，把每条边都加入集合，如果生成环就把边踢出集合，知道把所有边都遍历一遍就可以得到最小生成树 代码  利用并查集实现kurskal   12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class DSU &#123;private:    vector&lt;int&gt; parent;    int sets;public:    DSU(int n) : parent(n + 1) &#123;        for (int i = 1; i &lt;= n; i++) &#123;            parent[i] = i;            //sets++;        &#125;    &#125;     int find(int x) &#123;        return...</div></div></div></a><a class="pagination-related" href="/2025/04/15/AlgorithmAndDataStructure-2025-04-15-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E5%88%86%E6%B2%BB/" title="归并排序和归并分治"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">归并排序和归并分治</div></div><div class="info-2"><div class="info-item-1">  归并排序和归并分治  一、归并排序  介绍 不得不说，归并排序是一种非常稳定的排序方式，时间复杂度可以达到O(nlogn)O(nlogn)O(nlogn)级别，同样也是最坏情况下的最好的排序方式，主要思想就是把一个大问题分成两个子问题，把子问题搞定后再来合并 代码实现123456789101112131415161718192021222324252627282930313233vector&lt;int&gt; temp;void mergeSort(vector&lt;int&gt;&amp; a, int l, int r) &#123;    if (l &gt;= r) return;    int m = (l + r) / 2;    mergeSort(a, l, m);    mergeSort(a, m + 1, r);    int i = l, j = m + 1, k = l;    while (i &lt;= m &amp;&amp; j &lt;= r) &#123;        temp[k++] = (a[i] &lt;= a[j])...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/kurisu3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Kurisu</div><div class="author-info-description">学而不思则罔，思而不学则殆</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Kuur1su"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Kuur1su" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3325771476@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎参观！会随缘更新自己的学习生活quq。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">1.</span> <span class="toc-text">贪心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">一些经典例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-179-%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">LeetCode-179. 最大数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-1029-%E4%B8%A4%E5%9C%B0%E8%B0%83%E5%BA%A6"><span class="toc-number">2.2.</span> <span class="toc-text">LeetCode-1029. 两地调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-1553-%E5%90%83%E6%8E%89-N-%E4%B8%AA%E6%A9%98%E5%AD%90%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">LeetCode-1553. 吃掉 N 个橘子的最少天数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-630-%E8%AF%BE%E7%A8%8B%E8%A1%A8-III"><span class="toc-number">2.4.</span> <span class="toc-text">LeetCode-630. 课程表 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-LCR-132-%E7%A0%8D%E7%AB%B9%E5%AD%90-II"><span class="toc-number">2.5.</span> <span class="toc-text">LeetCode-LCR 132. 砍竹子 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">2.5.1.</span> <span class="toc-text">思路：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-number">2.6.</span> <span class="toc-text">LeetCode-435. 无重叠区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-2"><span class="toc-number">2.6.1.</span> <span class="toc-text">思路：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-1353-%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AE"><span class="toc-number">2.7.</span> <span class="toc-text">LeetCode-1353. 最多可以参加的会议数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-502-IPO"><span class="toc-number">2.8.</span> <span class="toc-text">LeetCode-502. IPO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-632-%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4"><span class="toc-number">2.9.</span> <span class="toc-text">LeetCode-632. 最小区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-3"><span class="toc-number">2.9.1.</span> <span class="toc-text">思路：</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/18/AlgorithmContest-2025-08-18-NKRound105/" title="NKRound105"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/screenshot01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NKRound105"/></a><div class="content"><a class="title" href="/2025/08/18/AlgorithmContest-2025-08-18-NKRound105/" title="NKRound105">NKRound105</a><time datetime="2025-08-18T00:21:14.000Z" title="发表于 2025-08-18 08:21:14">2025-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/17/AlgorithmAndDataStructure-2025-08-17-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" title="容斥原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/screenshot05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="容斥原理"/></a><div class="content"><a class="title" href="/2025/08/17/AlgorithmAndDataStructure-2025-08-17-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" title="容斥原理">容斥原理</a><time datetime="2025-08-17T01:16:38.000Z" title="发表于 2025-08-17 09:16:38">2025-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/17/AlgorithmAndDataStructure-2025-08-17-%E5%BF%AB%E9%80%9F%E5%B9%82/" title="快速幂"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="快速幂"/></a><div class="content"><a class="title" href="/2025/08/17/AlgorithmAndDataStructure-2025-08-17-%E5%BF%AB%E9%80%9F%E5%B9%82/" title="快速幂">快速幂</a><time datetime="2025-08-17T01:16:22.000Z" title="发表于 2025-08-17 09:16:22">2025-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/17/AlgorithmAndDataStructure-2025-08-17-%E8%B4%A8%E6%95%B0%E7%AD%9B/" title="质数筛"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/photo08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="质数筛"/></a><div class="content"><a class="title" href="/2025/08/17/AlgorithmAndDataStructure-2025-08-17-%E8%B4%A8%E6%95%B0%E7%AD%9B/" title="质数筛">质数筛</a><time datetime="2025-08-17T01:16:01.000Z" title="发表于 2025-08-17 09:16:01">2025-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/13/AlgorithmAndDataStructure-2025-08-13-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" title="贪心算法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/Roxy1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="贪心算法"/></a><div class="content"><a class="title" href="/2025/08/13/AlgorithmAndDataStructure-2025-08-13-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" title="贪心算法">贪心算法</a><time datetime="2025-08-13T00:12:24.000Z" title="发表于 2025-08-13 08:12:24">2025-08-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By Kurisu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  });
</script>
<canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/light.js"></script><script defer src="/js/runtimes.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><!-- hexo injector body_end end --></body></html>